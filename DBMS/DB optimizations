optimization Technique-->Purpose
Indexing-->Speed up searches
Avoid SELECT *-->Reduce data load
Joins over subqueries-->Better performance
EXPLAIN plan-->Analyze query performance
Normalization-->Remove redundancy
Caching-->Reduce DB hits
Partitioning based on certain columns of table-->Speed up large table queries
Proper data types-->Save memory and improve speed
LIMIT clause-->Control result size
Query tuning-->Use efficient syntax
Batching-->Fewer round-trips(insert/update in bulk rather than doing it by single row)
Connection pooling-->Reuse connections
Archiving-->Keep active tables small


1.Indexes:-

## 1. **Columns Frequently Used in WHERE Clauses**
- If a column is commonly used to filter records (e.g., `WHERE email = '...'`), it’s a good candidate for an index.

## 2. **Columns Used in JOIN Conditions**
- Columns that are used to join tables (e.g., `ON user_id = users.id`) should often be indexed.

## 3. **Columns Used in ORDER BY Clauses**
- If you often sort results by a column (e.g., `ORDER BY created_at`), indexing can speed up sorting.

## 4. **Columns Used in GROUP BY Clauses**
- If you aggregate data by a column (e.g., `GROUP BY category`), an index can help.

## 5. **Columns Frequently Searched for Uniqueness**
- Primary keys and columns with unique constraints are automatically indexed, but if you need to enforce uniqueness on other columns, add an index.

## 6. **Composite Indexes for Multi-Column Queries**
- If queries often filter by multiple columns together (e.g., `WHERE user_id = 5 AND status = 'active'`), a composite index on both columns is beneficial.

## 7. **Columns in Foreign Key Constraints**
- Foreign key columns are often indexed to speed up lookups and maintain referential integrity.

---

### **When NOT to Index**
- Columns that are rarely used in queries.
- Columns with very few unique values (low cardinality), such as boolean flags. (Exception: if you always filter by that column!)
- Columns that are frequently updated, as indexes add some overhead to write operations.

---

### **How to Decide?**
- **Analyze your query patterns**: Check which columns appear in WHERE, JOIN, ORDER BY, and GROUP BY clauses.
- **Use database EXPLAIN tools**: Most databases have a tool (like `EXPLAIN` in MySQL/Postgres) to show how queries are executed. Use it to see if indexes would help.
- **Monitor slow queries**: Index columns involved in your slowest queries.

---

2. Caching

Here’s how you can use **Redis as an external cache in a Spring Boot Java application**:

---

## **1. Add Redis Dependency**

Add the following to your `pom.xml` if you use Maven:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

---

## **2. Configure Redis in `application.properties`**

```properties
spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
# Optional: set time to live for cache entries
spring.cache.redis.time-to-live=60000
```

---

## **3. Enable Caching in Your Application**

Add `@EnableCaching` to your main application class:
```java
@SpringBootApplication
@EnableCaching
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

---

## **4. Use Caching Annotations in Your Services**

Example:
```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Cacheable(value = "users", key = "#id")
    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    @CacheEvict(value = "users", key = "#id")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }

    @CachePut(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}
```
- `@Cacheable`: Caches the result.
- `@CacheEvict`: Removes cache entry when data is deleted.
- `@CachePut`: Updates the cache when data is updated.

---

## **5. Run Redis Server**

Make sure a Redis server is running on the configured host and port (`localhost:6379` by default).

---

## **Summary Table**

| Step            | Description                                            |
|-----------------|-------------------------------------------------------|
| 1. Dependency   | Add Redis and cache starter dependencies              |
| 2. Configure    | Set Redis config in `application.properties`          |
| 3. Enable       | Add `@EnableCaching` in main app class                |
| 4. Annotate     | Use `@Cacheable`, `@CacheEvict`, `@CachePut` in code  |
| 5. Run Redis    | Start Redis server                                    |


Using Map-based Caching (Simple Java)
public class SimpleCache {
    private Map<Long, User> cache = new HashMap<>();

    public User getUserById(Long id) {
        if (cache.containsKey(id)) {
            return cache.get(id);
        }
        User user = dbFindUserById(id); // fetch from DB
        cache.put(id, user);
        return user;
    }
}
