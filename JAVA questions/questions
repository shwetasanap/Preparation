1) Stack and heap memory
In Java, memory refers to the space allocated by the Java Virtual Machine (JVM) for storing variables, objects, methods,
and other data during the execution of a program.

----> Stack Memory in Java
Stored in computer RAM
In Java, Stack Memory is a special region on the memory where the JVM (Java Virtual Machine) keeps track of method execution.

Stack Memory in Java is used for static memory allocation and the execution of a thread. 
It contains primitive values that are specific to a method and references to objects referred from the method that are in a heap.

Access to this memory is in Last-In-First-Out (LIFO) order. Whenever we call a new method, a new block is created on top of 
the stack which contains values specific to that method, like primitive variables and references to objects.

When the method finishes execution, its corresponding stack frame is flushed, the flow goes back to the calling method, and space becomes available for the next method.
If this memory is full, Java throws java.lang.StackOverFlowError.


----> Heap Memory in Java
Heap Memory facilitates Dynamic Memory Allocation for Java objects and JRE classes during program execution.
Objects in the heap have global access, available from any part of the application.

 Differenc
---> Java Heap Space is used throughout the application, but Stack is only used for the method — or methods — currently running.

******************************************************************************************************************************************************************************************

2) Static keyword

Used with method,variables and class
In  case of multiple blocks then they will execute in the order they are defined.
That’s the reason, values initialized by first block are overwritten by second block.


In Java, the main difference between static variables, static methods, and static classes 
is that static variables and methods are associated with a class, while a static class is a class type


A static variable is instantiated once, a static method can be called from a class without instantiating 
an instance of the class, a static class cannot be instantiated. 


******************************************************************************************************************************************************************************************
3) System.out.println() and  System.err.println() 

System: It is a final class defined in the java.lang package.
out: This is an instance of PrintStream type, which is a public and static member field of the System class.
println(): As all instances of the PrintStream class have a public method println(), we can invoke the same on out as well. 
This is an upgraded version of print(). It prints any argument passed to it and adds a new line to the output. 
We can assume that System.out represents the Standard Output Stream.


System.out.println() will print to the standard out of the system.	              System.err.println() will print to the standard error.
System.out.println() is mostly used to display results on the console.	          System.err.println() is mostly used to output error texts.
It gives output on the console with the default(black) color.	                    It also gives output on the console but most of the IDEs give it a red color to differentiate.


******************************************************************************************************************************************************************************************

4) stack or heap memory is cleared in the garbage collection
Garbage Collection runs on the heap memory to free the memory used by objects that don't have any reference. 

******************************************************************************************************************************************************************************************

5) Java supports several key object-oriented programming (OOP) features:

---> Encapsulation: Bundling the data (attributes) and methods (functions) that operate on the data into a single unit, usually a class. 
Access to the data is restricted to methods within the class, often using access modifiers (private, public, protected).

---> Inheritance: The ability to create a new class (subclass) that inherits properties and behaviors (methods) from an existing class
(superclass). This promotes code reuse and establishes a hierarchical relationship between classes.

---> Polymorphism: The ability to treat objects of different classes that share a common superclass as objects of that superclass.
This includes method overloading (same method name with different parameters) and method overriding (subclass providing a specific implementation of a method already defined in its superclass).

---> Abstraction: The concept of hiding complex implementation details and showing only the essential features of an object. 
This is often achieved using abstract classes and interfaces, allowing you to define methods that must be implemented by 
subclasses without specifying how they should be implemented.

---> Classes and Objects: Java uses classes as blueprints to create objects. An object is an instance of a class, and it encapsulates 
both data and behavior.

---> Method Overriding: A subclass can provide a specific implementation of a method that is already defined in its superclass. 
This is a key aspect of achieving polymorphism.

---> Interfaces: Java allows the definition of interfaces, which are contracts that classes can implement.
An interface can contain abstract methods (without implementation) and constants, promoting a way to achieve abstraction and
multiple inheritance.

******************************************************************************************************************************************************************************************

6) Diamond problem and it's solution 

The "diamond problem" in Java arises when a class inherits from two classes that both inherit from a common superclass, 
creating an ambiguous situation regarding which superclass's methods or properties should be used. This is particularly 
relevant in languages that support multiple inheritance, like C++, but Java handles this differently.


Sol-1 :-  Single inheritance
sol-2 :- use interfaces

Referring to Default Methods: When a class implements multiple interfaces that have the same default method, super allows 
the class to specify which interface's implementation to invoke.

Syntax: The syntax InterfaceName.super.methodName() is used to call a default method from a specific interface.
In this case, Car.super.start(); calls the start() method defined in the Car interface.

E.g. :- 

interface Vehicle {
    void start();
}

interface Car {
    default void start() {
        System.out.println("Car is starting.");
    }
}

interface Motorcycle {
    default void start() {
        System.out.println("Motorcycle is starting.");
    }
}

class HybridVehicle implements Car, Motorcycle {
    @Override
    public void start() {
        // Resolve ambiguity by explicitly calling one of the default methods
        Car.super.start(); // or Motorcycle.super.start();
        System.out.println("HybridVehicle is starting.");
    }
}

public class Main {
    public static void main(String[] args) {
        HybridVehicle hv = new HybridVehicle();
        hv.start();
    }
}
******************************************************************************************************************************************************************************************

7) Difference between local and instance variable

Feature	                   Local Variables	                         Instance Variables

Scope                  	Limited to method/block	                    Accessible throughout the class
Initialization	         Must be initialized explicitly	             Automatically initialized to default values
Memory Location	            Stored on the stack	                     Stored in the heap
Lifetime	             Exists only during method execution	           Exists as long as the object exists

******************************************************************************************************************************************************************************************

8) Difference between arraylist and linkedlist

Feature	                                 ArrayList	                    LinkedList
Data Structure                        	Dynamic array	               Doubly linked list
Access Time                           O(1)	                               O(n)
Insertion/Removal                    	O(n)	                       O(1) at ends; O(n) elsewhere
Memory Overhead	                     Less overhead	               More overhead due to pointers
Use Case                           	Frequent access by index	      Frequent insertions/removals


******************************************************************************************************************************************************************************************

9) Difference between hashmap and treemap



Feature	                             HashMap                                       	TreeMap
Data Structure	                    Hash table	                                    Red-black tree
Ordering	                          No order	                                      Sorted order
Access Time	                       O(1)                                           average	O(log n)
Space Complexity                   Less overhead                                 	More overhead
Null Keys/Values	                 One null key, multiple null values	             No null keys, but allows null values
Use Case                         	Fast access, no order needed	                   Sorted keys required


******************************************************************************************************************************************************************************************

10) Difference between hashset and treeset


Feature	                            HashSet	                                        TreeSet
Data Structure	                   Hash table                                     	Red-black tree
Ordering	                         No order                                       	Sorted order
Access Time	                      O(1)                                           average	O(log n)
Space Complexity	                Less overhead	                                  More overhead
Null Elements	                   Allows one null	                               No null elements allowed
Use Case	                       Fast access, no order needed	                   Sorted elements required


******************************************************************************************************************************************************************************************

11) Difference between iterator and listiterator


Feature	                            Iterator	                                      ListIterator
Supported Collections	              Any Collection	                                  Only List
Direction of Traversal	             Forward only	                              Forward and backward
Modification	                       Removes only	                            Removes and modifies elements
Additional Methods	                 Basic methods only                      	More methods for list manipulation
Methods	                            hasNext(), next(), remove()	            hasNext(), next(), hasPrevious(), previous(),
                                                                           nextIndex(), previousIndex(), set(E e), add(E e)

******************************************************************************************************************************************************************************************


12) what is the purpose of java.util.concurrent package

The package includes thread-safe variants of commonly used collections, such as:

ConcurrentHashMap: A thread-safe version of HashMap that allows concurrent access and modifications without blocking the entire map.


It provides several synchronization constructs, such as:

Locks: The Lock interface and its implementations (like ReentrantLock) offer more flexible locking mechanisms than the traditional
synchronized methods/blocks.

Condition Variables: Condition objects allow threads to wait for specific conditions and notify others when conditions change, 
enhancing the synchronization capabilities.


******************************************************************************************************************************************************************************************

13) How does exception propagate throughout the java code




******************************************************************************************************************************************************************************************
14) What is Java EE

Java EE, or Java Platform, Enterprise Edition, is a set of specifications and standards that extend the Java SE (Standard Edition) 
to provide a robust platform for developing large-scale, distributed, multi-tiered enterprise applications. 

******************************************************************************************************************************************************************************************

15) Difference between thread and process


Threads and processes are fundamental concepts in operating systems and concurrent programming, 
but they serve different purposes and have distinct characteristics. 


Feature	                                   Process	                                                Thread
Definition	                               Independent program in execution	           Smallest unit of processing within a process
Memory Allocation	                        Separate memory space	                      Shares memory space with other threads
Overhead                                 	Higher overhead (creation/management)	      Lower overhead (creation/management)
Isolation	                                Isolated from other processes	              Not isolated; can affect each other
Life Cycle	                               More complex life cycle                          	Simpler life cycle
Use Cases	                                Suitable for isolated tasks	               Suitable for concurrent tasks


******************************************************************************************************************************************************************************************

16) Synchronized and volatile keyword :-

The synchronized modifier is only for methods and blocks not for variables and classes. Synchronized keyword comes into the picture when multiple threads are trying to get access to the same java object simultaneously. A synchronized block or method allows only one thread at a time to execute on a given object, which will solve the problem of data inconsistency.
To use synchronized keywords in Java we have two ways 1) Synchronized method 2) Synchronized block


A volatile keyword is a field modifier that provides a visibility guarantee. Java uses volatile as an indicator to the Java compiler and thread that does not cache the value of this variable and always reads it from the main memory. The volatile keyword is only used with variables not with methods or classes.
When a variable is marked as volatile, any read or write to that variable is done directly from the main memory (not from thread-local caches).
This ensures that the latest value of the variable is visible to all threads. Without volatile, each thread might have its own copy of the variable 
in its cache, and changes made by one thread might not be visible to others.
Example:-

class Test
{
boolean flag = true;
}
In the above example, suppose two threads are working on the same class. Both threads run on different processors where each thread has its local copy of the flag. And if any thread changes the value of the flag, in the main memory the value will not get reflected and because the other threads are not aware of the changed value it will lead to data inconsistency.

class Test
{
volatile boolean flag = true;
}
In the above example, we have declared the flag as volatile so that the value of the variable will never be stored in the cache. And all the read and write operations will be done from and to the main memory.

******************************************************************************************************************************************************************************************

17) Priority of threads in java 

Every Java thread has a priority that helps the operating system determine the order in which threads are scheduled. 
You can get and set the priority of a Thread.

MIN_PRIORITY: Specifies the minimum priority that a thread can have. 1

NORM_PRIORITY: Specifies the default priority that a thread is assigned. 5

MAX_PRIORITY: Specifies the maximum priority that a thread can have. 10

******************************************************************************************************************************************************************************************

18) Context switching in java

Thread Context Switch is a process of switching the working from one thread to another. The computer CPU stores the state of current 
thread, so that it can be retured later. Next it switches to the next thread, picks it where it was left before, and continuous to 
start working.

******************************************************************************************************************************************************************************************

19) sleep() and wait()

While the sleep() function is time-dependent and doesn't need any notice, the wait() method is time-independent and requires
notification from another thread. 

sleep --> does not releases lock on resource  
wait --> releases lock on resource 


******************************************************************************************************************************************************************************************

20) What is an atomic object

In Java, an atomic object typically refers to an object that provides atomic operations, ensuring that operations on it are completed
without interference, particularly in multi-threaded environments. The java.util.concurrent.atomic package provides classes like 
AtomicInteger, AtomicLong, AtomicReference, etc., which allow atomic operations on single variables.

In Java, atomic operations are generally provided by the java.util.concurrent.atomic package, which includes classes designed to 
safely manipulate variables in a multithreaded environment.

Key Concepts:
Atomic Variables: These are variables for which atomic operations (such as read, write, increment, etc.) are provided without needing synchronization.
Atomic Classes: Java provides several atomic classes, such as AtomicInteger, AtomicLong, AtomicReference, etc., to handle variables atomically.
These atomic classes provide a higher-level alternative to using synchronized blocks or methods for thread safety.

Atomic Classes in Java
AtomicInteger: Provides atomic operations for an int value.
AtomicLong: Provides atomic operations for a long value.
AtomicBoolean: Provides atomic operations for a boolean value.
AtomicReference: Provides atomic operations for an object reference.


******************************************************************************************************************************************************************************************

21) Optional class


Every Java Programmer is familiar with NullPointerException. It can crash your code. And it is very hard to avoid it without using too many null checks.
So, to overcome this, Java 8 has introduced a new class Optional in java.util package. It can help in writing a neat code without using too many null checks. 
Optional is a container object which may or may not contain a non-null value. You must import java.util package to use this class. If a value is present,
isPresent() will return true and get() will return the value.

empty(): Returns an empty Optional object 
of(value): Returns an Optional with a non-null value 
ofNullable(value): Returns an Optional with a value if it's not null, or an empty Optional if it is null 
isPresent(): Returns true if a value is present, and false if it's not 
get(): Returns the value if it's present, or throws NoSuchElementException if it's not 
orElse(): Used to deal with Optional values when the value may or may not be present 
orElseGet(): Used to deal with Optional values when the value may or may not be present 
orElseThrow(): Used to deal with Optional values when the value may or may not be present 




******************************************************************************************************************************************************************************************

22) Lambda expressions

Lambda expressions in Java, introduced in Java SE 8, represent instances of functional interfaces (interfaces with a single abstract method). 
They provide a concise way to express instances of single-method interfaces using a block of code.

Functionalities of Lambda Expression
Lambda Expressions implement the only abstract function and therefore implement functional interfaces lambda expressions are added in Java 8 and provide the below functionalities.

Functional Interfaces: A functional interface is an interface that contains only one abstract method.
Code as Data: Treat functionality as a method argument.
Class Independence: Create functions without defining a class.
Pass and Execute: Pass lambda expressions as objects and execute on demand.

@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);  // Single abstract method (SAM)
}

public class LambdaExample {
    public static void main(String[] args) {
        // Using lambda to implement the MathOperation interface
        MathOperation add = (a, b) -> a + b;
        MathOperation subtract = (a, b) -> a - b;

        System.out.println("Addition: " + add.operate(5, 3));        // Output: 8
        System.out.println("Subtraction: " + subtract.operate(5, 3)); // Output: 2
    }
}

import java.util.*;

public class LambdaExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Alice", "Bob", "Charlie");

        // Sort names by length using a lambda expression
        Collections.sort(names, (a, b) -> a.length() - b.length());

        System.out.println(names);  // Output: [Bob, John, Alice, Charlie]
    }
}

public class LambdaExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);

        // Square each number and then sum them using map() and reduce()
        int sumOfSquares = numbers.stream()
                                  .map(n -> n * n)               // Square each number
                                  .reduce(0, (a, b) -> a + b);   // Sum them up

        System.out.println("Sum of squares: " + sumOfSquares);  // Output: 30
    }
}

******************************************************************************************************************************************************************************************

23) User defined Marker interfaces

In Java, a marker interface is an interface that does not contain any methods. Its primary purpose is to signal to the JVM or a framework that the implementing class 
possesses certain properties or capabilities. Marker interfaces are often used for metadata tagging to provide additional information about a class without modifying
its behavior directly.

Key Points about Marker Interfaces:
A marker interface does not declare any methods.
It is used to tag or mark a class for special treatment by the JVM or libraries.
The presence of the interface is checked by the program at runtime, usually with the instanceof operator, or by using reflection.
Marker interfaces help achieve a form of type checking.


public class MarkerInterfaceExample {
    public static void main(String[] args) {
        UserData user = new UserData("Alice", 25);

        // Check if the object is an instance of the Serializable interface
        if (user instanceof Serializable) {
            System.out.println("UserData is serializable");
        } else {
            System.out.println("UserData is not serializable");
        }
    }
}

Marker interfaces are interfaces that don’t contain methods but are used to provide metadata or to tag a class for special processing.
You can create your own custom marker interfaces to indicate that certain behavior should be applied to the marked classes.
They are often used for purposes like serialization, cloning, security checks, and threading.


public class ValidationExample {
    public static void main(String[] args) {
        User user = new User("Alice", 25);

        // Check if the class is validatable --> it is just a no method user defined interface.If object is instance of validatable then it should perform or implement or pass the
mentioned validations.
        if (user instanceof Validatable) {
            System.out.println("Validating user: " + user.getName());
            // Perform validation (for example, checking if age is valid)
            if (user.getAge() < 18) {
                System.out.println("User is not valid.");
            } else {
                System.out.println("User is valid.");
            }
        } else {
            System.out.println("User is not validatable.");
        }
    }
}



******************************************************************************************************************************************************************************************


24) Equals() and hashCode() methods (Significance & Best Practices)

The equals() and hashCode() methods in Java are fundamental for working with collections, ensuring object comparison consistency,
and providing effective hashing mechanisms.


Significance of equals() and hashCode()

equals() Method:

The equals() method is used to compare two objects for logical equality.
By default, the equals() method in the Object class compares object references (i.e., checks if two objects are the same in memory).
When you override equals(), you're telling Java how to compare the contents or attributes of two objects.

hashCode() Method:

The hashCode() method provides a unique integer (hash code) representation of an object.
It is used in hashing algorithms to efficiently store and retrieve objects in collections like HashMap, HashSet, and Hashtable.
The hashCode() method ensures that objects that are logically equal (i.e., equals() returns true) must have the same hash code.

When you override equals(), you must also override hashCode() to maintain the general contract between them. 


When comparing objects in equals(), use instanceof to ensure you're comparing objects of the correct type. This avoids ClassCastException
Best Practices for Overriding equals() and hashCode()

Override both methods:

Whenever you override equals(), also override hashCode() to maintain the contract. Failing to do so may result in inconsistent
behavior in hash-based collections.

Use the @Override annotation:

Always use the @Override annotation to ensure you're overriding the correct methods, which also improves code readability and reduces errors.


instanceof is a keyword used in Java to check if an object is an instance of a specific class or subclass. 
It returns true if the object is of the specified type or a type that inherits from it, and false otherwise.

The getClass() method is a method of the Object class, and every Java object inherits it.
It returns the runtime class of the object, i.e., the exact type of the object at the moment.

******************************************************************************************************************************************************************************************


Object Cloning (Shallow Copy vs Deep Copy)

Cloning means creating a copy of an object in Java.

Shallow Copy: Only the outer object is copied. If the object has other objects inside it (like an address or list), those inner objects 
are not copied; they are just shared between the original and the copy.

 @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();  // Shallow copy (does not copy address)
    }

Deep Copy: Both the outer object and all the inner objects are completely copied. The original and the copied object don’t share anything.

  @Override
    public Object clone() throws CloneNotSupportedException {
        // Deep copy: Clone the Address object as well
        Person clonedPerson = (Person) super.clone();
        clonedPerson.address = (Address) address.clone();  // Deep copy for Address
        return clonedPerson;
    }


The Cloneable interface is a marker interface in Java, meaning it doesn't contain any methods. 
The purpose of this interface is to indicate that an object can be cloned using the clone() method.
If a class does not implement Cloneable, calling the clone() method on its object will throw a CloneNotSupportedException.

If you want to clone an object of a custom class, that class must implement Cloneable.
By default, clone() performs a shallow copy (it only copies the object itself, not the objects it refers to).
If you want a deep copy (where nested objects are cloned as well), you need to override the clone() method (method in Object class) in your 
class and implement the deep cloning logic.

----> super.clone() to perform the default cloning

******************************************************************************************************************************************************************************************

Aspect	                        Tight Coupling	                                                 Loose Coupling

Dependency	                 Strong dependency between classes.	                         Minimal or no direct dependency.
Flexibility	                Hard to modify without affecting other components.	         Easier to modify and extend.
Maintainability	            Difficult to maintain and refactor.                        	Easier to maintain and refactor.
Testability	                Difficult to test in isolation.                            	Easier to test individual components.
Reusability	                Difficult to reuse classes independently.	                  Easier to reuse classes independently.



class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine = new Engine(); // Tight coupling

    public void drive() {
        engine.start();
        System.out.println("Car is driving");
    }
}



interface Engine {
    void start();
}

class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol engine started");
    }
}

class ElectricEngine implements Engine {
    public void start() {
        System.out.println("Electric engine started");
    }
}

class Car {
    private Engine engine;

    public Car(Engine engine) {
        this.engine = engine; // Loose coupling through dependency injection
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving");
    }
}

******************************************************************************************************************************************************************************************


SOLID Principles in Java

The SOLID principles are a set of design principles that help developers create more maintainable, flexible, and scalable software. 
They are particularly useful in object-oriented programming (OOP) and are often used in Java development. 


1. Single Responsibility Principle (SRP)
Definition: A class should have only one reason to change, meaning it should have only one responsibility or job.
In Java: If a class is responsible for multiple unrelated tasks, it becomes harder to maintain. 
You should refactor such classes into smaller, focused classes, each handling one responsibility.

2. Open/Closed Principle (OCP)
Definition: Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
In Java: You should be able to add new functionality to a class without modifying its existing code. 
This is often achieved using inheritance or interfaces.

interface Shape {
    double area();
}

class Circle implements Shape {
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    public double area() { return Math.PI * radius * radius; }
}

class Rectangle implements Shape {
    private double width, height;
    public Rectangle(double width, double height) { this.width = width; this.height = height; }
    public double area() { return width * height; }
}

class AreaCalculator {
    public double calculateArea(Shape shape) { //recieves specific shape implementation in constructor --> dependency injection
        return shape.area();
    }
}

3. Liskov Substitution Principle (LSP)
Definition: Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.
In Java: A subclass should be able to substitute a superclass object without altering the desired behavior of the program. 
This means the subclass should honor the behavior expected of the superclass.



class Bird {
    public void fly() { System.out.println("Flying"); }
}

class Sparrow extends Bird {
    public void fly() { System.out.println("Sparrow flying"); }
}

class Penguin extends Bird {
    // Violates LSP because penguins can't fly, which breaks expected behavior
    public void fly() { throw new UnsupportedOperationException("Penguins can't fly!"); }
}


4. Interface Segregation Principle (ISP)
Definition: Clients should not be forced to depend on interfaces they do not use.
In Java: Instead of having a large, all-encompassing interface, you should break it into smaller, more specific interfaces. 
This way, classes implement only the methods that are relevant to them.



interface Animal {
    void eat();
    void sleep();
    void fly();
}

class Dog implements Animal {
    public void eat() { /* Dog eating */ }
    public void sleep() { /* Dog sleeping */ }
    public void fly() { throw new UnsupportedOperationException("Dogs can't fly!"); }
}

The above violates ISP because the Dog class is forced to implement the fly() method, which it doesn't need. 

interface Animal {
    void eat();
    void sleep();
}

interface Flyable {
    void fly();
}

class Dog implements Animal {
    public void eat() { /* Dog eating */ }
    public void sleep() { /* Dog sleeping */ }
}

class Bird implements Animal, Flyable {
    public void eat() { /* Bird eating */ }
    public void sleep() { /* Bird sleeping */ }
    public void fly() { /* Bird flying */ }
}

5. Dependency Inversion Principle (DIP)
Definition: High-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore, 
abstractions should not depend on details. Details should depend on abstractions.
In Java: The idea is to decouple high-level business logic from low-level details (like specific implementations) 
using interfaces or abstract classes. This can be achieved through techniques like dependency injection.


class LightBulb {
    public void turnOn() { System.out.println("LightBulb turned on"); }
    public void turnOff() { System.out.println("LightBulb turned off"); }
}

class Switch {
    private LightBulb bulb;
    public Switch(LightBulb bulb) { this.bulb = bulb; }

    public void operate() {
        // simple dependency, tightly coupled
        bulb.turnOn();
    }
}
This design violates DIP because Switch depends directly on the LightBulb. To follow DIP, we can introduce an abstraction (interface):

interface Switchable {
    void turnOn();
    void turnOff();
}

class LightBulb implements Switchable {
    public void turnOn() { System.out.println("LightBulb turned on"); }
    public void turnOff() { System.out.println("LightBulb turned off"); }
}

class Switch {
    private Switchable device;
    public Switch(Switchable device) { this.device = device; }

    public void operate() {
        device.turnOn();
    }
}

******************************************************************************************************************************************************************************************

CopyOnWriteArrayList :-

CopyOnWriteArrayList is a class in Java that belongs to the java.util.concurrent package and is a part of the Java Collections framework.
It is a thread-safe variant of the ArrayList. The key feature of CopyOnWriteArrayList is that it handles concurrency by making a 

fresh copy of the underlying array whenever a modification (such as adding or removing elements) occurs.

Concurrency: It's thread-safe, but the trade-off is the performance overhead of copying the array for write operations.
Ideal Usage: Best suited for applications with a lot of reads and fewer writes.
No Synchronization Needed: No external synchronization is required when using CopyOnWriteArrayList because it ensures thread safety internally.


As the name indicates, CopyOnWriteArrayList creates a Cloned copy of underlying ArrayList, for every update operation at a certain point both will be synchronized automatically, which is taken care of by JVM. Therefore, there is no effect for threads that are performing read operation.
It is costly to use because for every update operation a cloned copy will be created. Hence, CopyOnWriteArrayList is the best choice if our frequent operation is read operation.
The underlined data structure is a grow-able array.
It is a thread-safe version of ArrayList.
Insertion is preserved, duplicates, null, and heterogeneous Objects are allowed.
The main important point about CopyOnWriteArrayList is the Iterator of CopyOnWriteArrayList can not perform remove operation otherwise we get Run-time exception saying 
UnsupportedOperationException. add() and set() methods on CopyOnWriteArrayList iterator also throws UnsupportedOperationException. Also Iterator of CopyOnWriteArrayList
will never throw ConcurrentModificationException.

******************************************************************************************************************************************************************************************


Fail-Fast vs Fail-Safe Collections


In the context of programming and data structures, Fail-Fast and Fail-Safe refer to different approaches in how collections
(like lists, sets, or maps) behave when they are modified while being iterated over. 

Fail-Fast Collections
Definition: A collection is considered "fail-fast" when it immediately throws an exception if it detects that it has been structurally modified (i.e., changed in terms of adding or removing elements) while it is being iterated over.
Behavior: If an iterator is actively traversing a collection and the collection is modified (such as by adding or removing elements), the collection will throw a ConcurrentModificationException (in Java, for example) to signal that something has gone wrong.
Advantages:
Helps detect errors early, making them easier to debug.
Prevents undefined behavior or incorrect results when working with multi-threaded programs or when modifying the collection during iteration.
Disadvantages:
The program may throw exceptions unexpectedly during iteration if the collection is modified.
Requires developers to handle concurrent modifications carefully, typically with synchronization or locks.


List<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);

Iterator<Integer> iterator = list.iterator();
list.add(3);  // This will cause ConcurrentModificationException during iteration
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}


Fail-Safe Collections
Definition: A collection is considered "fail-safe" when it doesn’t throw exceptions if it is modified during iteration. Instead, fail-safe collections allow the iteration to continue and typically work on a copy or snapshot of the data.
Behavior: Fail-safe collections use a copy or snapshot mechanism to avoid issues with structural modifications. Even if the collection is modified during iteration (either by adding or removing elements), the iteration process continues over the original state of the collection, unaffected by the changes.
Advantages:
It avoids exceptions, which can be beneficial in some cases, particularly in concurrent systems where you may expect modifications during iteration.
Makes iteration easier in multithreaded environments, as it doesn't require explicit synchronization.
Disadvantages:
Can introduce overhead, as collections may create copies of themselves during iteration, leading to increased memory usage and potentially slower performance.
The behavior can be unpredictable if you expect changes to be reflected during iteration, as you are iterating over a snapshot of the collection at a given point in time.

List<Integer> list = new CopyOnWriteArrayList<>();
list.add(1);
list.add(2);

Iterator<Integer> iterator = list.iterator();
list.add(3);  // No ConcurrentModificationException, the iteration continues normally
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}

Conclusion:
Fail-Fast collections are ideal when you want to quickly detect and fix problems with concurrent modifications in a collection. 
However, they require careful management of how and when modifications happen during iteration.
Fail-Safe collections are more tolerant and safe for concurrent modifications but may come with performance trade-offs due to 
the overhead of copying the collection.


******************************************************************************************************************************************************************************************

ConcurrentHashMap & Its Working

A ConcurrentHashMap is a part of Java's java.util.concurrent package, and it is a thread-safe, high-performance map implementation 
that allows concurrent access to its elements by multiple threads without the need for external synchronization.

Key Features of ConcurrentHashMap:

Thread Safety: Unlike a regular HashMap, ConcurrentHashMap ensures that concurrent read and write operations can be performed 
safely by multiple threads without corrupting the underlying data.

Locking Mechanism:
It uses a bucket-level locking mechanism (also known as segment locking) instead of locking the entire map like Hashtable does. This enables multiple threads to access different segments of the map concurrently.
The map is divided into multiple segments (buckets), and each segment can be locked independently when modifications are being made.
This reduces contention and increases the throughput.

Non-blocking Reads:
Reads do not require locking, so multiple threads can read from the map simultaneously without any performance degradation.
Atomic Operations: Operations like putIfAbsent(), remove(), and replace() are atomic and thread-safe.

Concurrency Levels:
You can specify the number of concurrent segments when creating a ConcurrentHashMap (default is 16), allowing you to control 
the granularity of the locking.

How It Works:
Internally, ConcurrentHashMap is divided into segments. Each segment is essentially a smaller hash map with its own locks. This approach minimizes the contention on the entire map, as different threads may work on different segments simultaneously.

Here is how the basic operations work in ConcurrentHashMap:

Read Operation:
A read operation is non-blocking. Multiple threads can read from different segments at the same time without locking.
Write Operation:
A write operation requires locking the segment that the key belongs to. But since different segments can be locked independently, 
other threads can still write to other segments concurrently.
Update Operations (like putIfAbsent(), replace(), etc.):
These operations are atomic. If multiple threads try to update the same key, one will succeed, and the others will fail gracefully.

In summary, ConcurrentHashMap is an excellent choice when you need a high-performance, thread-safe map that allows concurrent 
access without requiring external synchronization. Its fine-grained locking mechanism helps achieve better concurrency and 
throughput in multi-threaded applications.

******************************************************************************************************************************************************************************************

Java 8 Features (Most Asked in Interviews)

1. Lambda Expressions
2. Functional Interfaces
3. Stream API
4. Default Methods --> Java 8 allows interfaces to have default methods with implementation. This helps in adding new methods to interfaces without 
                       breaking existing implementations.
5. Method References
6. Optional Class
7. Parallel Streams

******************************************************************************************************************************************************************************************


Predicate, Consumer, Supplier, Function 

In Java 8, the java.util.function package introduced several functional interfaces, including Predicate, Consumer, Supplier, and Function.
These are essential for functional programming in Java and are commonly used in lambda expressions and streams. 

1. Predicate<T>
A Predicate is a functional interface that represents a condition or boolean test. It takes an argument of type T and returns
a boolean value (true or false).

Signature: boolean test(T t)
Use Case: It is often used for filtering data in streams or conditions where you need to evaluate whether a condition is true or false.

Predicate<String> isLengthGreaterThan3 = str -> str.length() > 3;

System.out.println(isLengthGreaterThan3.test("Java"));  // true
System.out.println(isLengthGreaterThan3.test("Hi"));    // false


2. Consumer<T>
A Consumer represents an operation that takes a single input of type T and returns no result.
It is typically used for performing an action (side effect) such as printing, modifying values, etc.

Signature: void accept(T t)
Use Case: It’s often used for operations that modify an object, print to the console, or have some other side effect.

Consumer<String> printUpperCase = str -> System.out.println(str.toUpperCase());

printUpperCase.accept("hello");  // Output: HELLO

Common Methods:
andThen(Consumer<? super T> after) (to chain multiple consumers)

3. Supplier<T>
A Supplier represents a supplier of results. It doesn't take any arguments but returns a value of type T. 
It's typically used when you want to generate or provide values, like generating random numbers, or providing default values.

Signature: T get()
Use Case: It’s often used when you want to generate or supply an object but don't need any input.

Supplier<String> provideString = () -> "Hello, World!";

System.out.println(provideString.get());  // Output: Hello, World!

4. Function<T, R>
A Function represents a function that takes an argument of type T and produces a result of type R. 
It is used for transformation or mapping operations.

Signature: R apply(T t)
Use Case: It’s useful for converting or mapping one type of object into another, such as converting strings to 
integers or transforming a list of objects.

Function<String, Integer> stringLength = str -> str.length();

System.out.println(stringLength.apply("Hello"));  // Output: 5


******************************************************************************************************************************************************************************************

Executor Framework & Thread Pooling

The Executor Framework provides a high-level API to manage and control concurrent tasks in Java.
Thread Pooling reduces the overhead of repeatedly creating and destroying threads by reusing a fixed number of threads.
ExecutorService and ThreadPoolExecutor help in managing threads and queues efficiently, improving performance and resource 
management in multithreaded applications.
By leveraging the Executor framework and thread pooling, developers can ensure efficient thread management, 
improve application scalability, and reduce resource overhead.


******************************************************************************************************************************************************************************************

 Starvation & Race Conditions

1. Starvation
Starvation happens when a thread (a unit of work in your program) doesn't get a chance to run. 
It’s like a thread waiting for its turn forever, while other threads are constantly getting priority and never letting it run.

Example: Imagine you have several workers (threads), but some workers are always getting tasks (CPU time), 
while others are kept waiting and never get a chance to work.

How to avoid it:

Make sure that threads get a fair chance to run by using fair locks or setting up thread priorities correctly.

2. Race Condition
A race condition occurs when two or more threads try to access and change the same data at the same time. 
This can cause problems because the threads might interfere with each other and give wrong results.

Example: Imagine two people trying to update a bank account balance at the same time without checking each other’s work.
One person could overwrite the other’s changes, causing an incorrect balance.

How to avoid it:

Make sure only one thread can access or modify shared data at a time. You can do this by using synchronized blocks or
using special classes like AtomicInteger which handle thread safety automatically.

Key Differences:
Starvation is about a thread being ignored and never getting a chance to run.
Race Condition happens when threads mess with shared data at the same time and mess things up.


******************************************************************************************************************************************************************************************


Java Class Loading Mechanism & ClassLoader Hierarchy


In Java, class loading refers to the process by which Java runtime environment (JRE) loads the classes needed for the program to run.
The class loading mechanism is part of the Java Runtime Environment (JRE) that loads, links, and initializes classes.

Here’s a breakdown of how class loading works in Java:

Class Loader (JVM Class Loading): The class loader is responsible for loading class files from the file system or network into the
Java Virtual Machine (JVM). When you run a Java program, the JVM doesn't know where the classes are located initially, so it relies 
on the class loader to locate and load classes dynamically into memory.

Class Loading Process:

Loading: When a class is first referenced, the class loader looks for the corresponding .class file (bytecode) on the local 
file system, a network resource, or another source.
Linking: This involves verification (checking bytecode for validity), preparation (assigning memory for static variables),
and optional resolution (substituting symbolic references with actual references).
Initialization: After a class has been loaded and linked, it is initialized, which involves executing static blocks, 
initializing static variables, and preparing the class for use.

ClassLoader Hierarchy

The class loader hierarchy in Java is structured as a tree, with multiple class loaders that form a chain of responsibility. 
There are three major class loaders:

Bootstrap ClassLoader (Primordial ClassLoader):

The Bootstrap ClassLoader is the parent of all class loaders in Java and is part of the core Java runtime environment.
It loads core Java classes, such as those in the java.lang, java.util, java.net, and other fundamental packages, from the 
Java Runtime Environment (JRE).
The classes it loads are typically stored in the rt.jar (or similar file) in the JRE.

Extension ClassLoader (Platform ClassLoader):

The Extension ClassLoader is responsible for loading classes from the JDK extension directory (jre/lib/ext) or any custom classpath 
specified.
It loads classes related to standard Java extensions (such as JDBC, JCE) that extend the functionality of the core Java platform.


System/Application ClassLoader (User ClassLoader):

The System ClassLoader, also known as the Application ClassLoader, is responsible for loading classes that are part of the classpath of your application.
It loads classes from locations such as the classpath (including .jar files or directories). This is the default class loader for most user applications.
It is the one typically responsible for loading the classes specified when running the program via the java -cp command.
ClassLoader Hierarchy in Java
The class loader hierarchy follows a parent-child relationship:

Bootstrap ClassLoader (parent to all class loaders) -> It cannot be directly instantiated.
Extension ClassLoader (child of Bootstrap ClassLoader) -> Responsible for loading classes from the JDK extensions.
System/Application ClassLoader (child of Extension ClassLoader) -> Responsible for loading application-level classes.
When a class is requested, the class loader first delegates the request to its parent. If the parent class loader can’t find the class, it will load the class itself.

Example:
If an application class A needs to load class B, the following hierarchy applies:

ClassLoader for class A will first delegate the request to its parent class loader (which could be the system class loader or the extension class loader).
If the parent class loader doesn't find the class, the current class loader will try to load it itself.
If none of the class loaders can find it, a ClassNotFoundException will be thrown.
Custom ClassLoader in Java
Java allows you to create custom class loaders by extending the ClassLoader class. This is particularly useful when:

Loading classes from non-standard locations (like databases, network resources).
Implementing a special class loading behavior (like reloading classes in a hot-swapping application).
A custom class loader can override the findClass method to load classes from custom sources.


******************************************************************************************************************************************************************************************

.war file into .jar to run 
