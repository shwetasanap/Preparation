

1) Stack and heap memory
In Java, memory refers to the space allocated by the Java Virtual Machine (JVM) for storing variables, objects, methods,
and other data during the execution of a program.

----> Stack Memory in Java
Stored in computer RAM
In Java, Stack Memory is a special region on the memory where the JVM (Java Virtual Machine) keeps track of method execution.

Stack Memory in Java is used for static memory allocation and the execution of a thread. 
It contains primitive values that are specific to a method and references to objects referred from the method that are in a heap.

Access to this memory is in Last-In-First-Out (LIFO) order. Whenever we call a new method, a new block is created on top of 
the stack which contains values specific to that method, like primitive variables and references to objects.

When the method finishes execution, its corresponding stack frame is flushed, the flow goes back to the calling method, and space becomes available for the next method.
If this memory is full, Java throws java.lang.StackOverFlowError.


----> Heap Memory in Java
Heap Memory facilitates Dynamic Memory Allocation for Java objects and JRE classes during program execution.
Objects in the heap have global access, available from any part of the application.

 Difference
---> Java Heap Space is used throughout the application, but Stack is only used for the method — or methods — currently running.

******************************************************************************************************************************************************************************************

2) Static keyword

Used with method,variables and class
In  case of multiple blocks then they will execute in the order they are defined.
That’s the reason, values initialized by first block are overwritten by second block.


In Java, the main difference between static variables, static methods, and static classes 
is that static variables and methods are associated with a class, while a static class is a class type


A static variable is instantiated once, a static method can be called from a class without instantiating 
an instance of the class, a static class cannot be instantiated. 

Declaration: Use the static keyword inside another class.
No Outer Instance Needed: You can create an instance of a static inner class without creating an instance of the outer class.
Access: It can access only static members (fields and methods) of the outer class directly.
Use Cases: Often used to group classes that will only be used in one place, or to logically associate helper classes with their outer class.

******************************************************************************************************************************************************************************************
3) System.out.println() and  System.err.println() 

System: It is a final class defined in the java.lang package.
out: This is an instance of PrintStream type, which is a public and static member field of the System class.
println(): As all instances of the PrintStream class have a public method println(), we can invoke the same on out as well. 
This is an upgraded version of print(). It prints any argument passed to it and adds a new line to the output. 
We can assume that System.out represents the Standard Output Stream.


System.out.println() will print to the standard out of the system.	              System.err.println() will print to the standard error.
System.out.println() is mostly used to display results on the console.	          System.err.println() is mostly used to output error texts.
It gives output on the console with the default(black) color.	                    It also gives output on the console but most of the IDEs give it a red color to differentiate.


******************************************************************************************************************************************************************************************

4) stack or heap memory is cleared in the garbage collection
Garbage Collection runs on the heap memory to free the memory used by objects that don't have any reference. 

******************************************************************************************************************************************************************************************

5) Java supports several key object-oriented programming (OOP) features:

---> Encapsulation: Bundling the data (attributes) and methods (functions) that operate on the data into a single unit, usually a class. 
Access to the data is restricted to methods within the class, often using access modifiers (private, public, protected).

---> Inheritance: The ability to create a new class (subclass) that inherits properties and behaviors (methods) from an existing class
(superclass). This promotes code reuse and establishes a hierarchical relationship between classes.

---> Polymorphism: The ability to treat objects of different classes that share a common superclass as objects of that superclass.
This includes method overloading (same method name with different parameters) and method overriding (subclass providing a specific implementation of a method already defined in its superclass).

---> Abstraction: The concept of hiding complex implementation details and showing only the essential features of an object. 
This is often achieved using abstract classes and interfaces, allowing you to define methods that must be implemented by 
subclasses without specifying how they should be implemented.

---> Classes and Objects: Java uses classes as blueprints to create objects. An object is an instance of a class, and it encapsulates 
both data and behavior.

---> Method Overriding: A subclass can provide a specific implementation of a method that is already defined in its superclass. 
This is a key aspect of achieving polymorphism.

---> Interfaces: Java allows the definition of interfaces, which are contracts that classes can implement.
An interface can contain abstract methods (without implementation) and constants, promoting a way to achieve abstraction and
multiple inheritance.

Static Methods in Interface are those methods, which are defined in the interface with the keyword static. 
Unlike other methods in Interface, these static methods contain the complete definition of the function and 
since the definition is complete and the method is static, therefore these methods cannot be overridden or 
changed in the implementation class.
Similar to Default Method in Interface, the static method in an interface can be defined in the interface, 
but cannot be overridden in Implementation Classes.

 default methods can be overridden if needed in the implementation.

******************************************************************************************************************************************************************************************

6) Diamond problem and it's solution 

The "diamond problem" in Java arises when a class inherits from two classes that both inherit from a common superclass, 
creating an ambiguous situation regarding which superclass's methods or properties should be used. This is particularly 
relevant in languages that support multiple inheritance, like C++, but Java handles this differently.


Sol-1 :-  Single inheritance
sol-2 :- use interfaces

Referring to Default Methods: When a class implements multiple interfaces that have the same default method, super allows 
the class to specify which interface's implementation to invoke.

Syntax: The syntax InterfaceName.super.methodName() is used to call a default method from a specific interface.
In this case, Car.super.start(); calls the start() method defined in the Car interface.

E.g. :- 

interface Vehicle {
    void start();
}

interface Car {
    default void start() {
        System.out.println("Car is starting.");
    }
}

interface Motorcycle {
    default void start() {
        System.out.println("Motorcycle is starting.");
    }
}

class HybridVehicle implements Car, Motorcycle {
    @Override
    public void start() {
        // Resolve ambiguity by explicitly calling one of the default methods
        Car.super.start(); // or Motorcycle.super.start();
        System.out.println("HybridVehicle is starting.");
    }
}

public class Main {
    public static void main(String[] args) {
        HybridVehicle hv = new HybridVehicle();
        hv.start();
    }
}
******************************************************************************************************************************************************************************************

7) Difference between local and instance variable

Feature	                   Local Variables	                         Instance Variables

Scope                  	Limited to method/block	                    Accessible throughout the class
Initialization	         Must be initialized explicitly	             Automatically initialized to default values
Memory Location	            Stored on the stack	                     Stored in the heap
Lifetime	             Exists only during method execution	           Exists as long as the object exists

******************************************************************************************************************************************************************************************

8) Difference between arraylist and linkedlist

Feature	                                 ArrayList	                    LinkedList
Data Structure                        	Dynamic array	               Doubly linked list
Access Time                           O(1)	                               O(n)
Insertion/Removal                    	O(n)	                       O(1) at ends; O(n) elsewhere
Memory Overhead	                     Less overhead	               More overhead due to pointers
Use Case                           	Frequent access by index	      Frequent insertions/removals


******************************************************************************************************************************************************************************************

9) Difference between hashmap and treemap



Feature	                             HashMap                                       	TreeMap
Data Structure	                    Hash table	                                    Red-black tree
Ordering	                          No order	                                      Sorted order
Access Time	                       O(1)                                           average	O(log n)
Space Complexity                   Less overhead                                 	More overhead
Null Keys/Values	                 One null key, multiple null values	             No null keys, but allows null values
Use Case                         	Fast access, no order needed	                   Sorted keys required


******************************************************************************************************************************************************************************************

10) Difference between hashset and treeset


Feature	                            HashSet	                                        TreeSet
Data Structure	                   Hash table                                     	Red-black tree
Ordering	                         No order                                       	Sorted order
Access Time	                      O(1)                                           average	O(log n)
Space Complexity	                Less overhead	                                  More overhead
Null Elements	                   Allows one null	                               No null elements allowed
Use Case	                       Fast access, no order needed	                   Sorted elements required


******************************************************************************************************************************************************************************************

11) Difference between iterator and listiterator


Feature	                            Iterator	                                      ListIterator
Supported Collections	              Any Collection	                                  Only List
Direction of Traversal	             Forward only	                              Forward and backward
Modification	                       Removes only	                            Removes and modifies elements
Additional Methods	                 Basic methods only                      	More methods for list manipulation
Methods	                            hasNext(), next(), remove()	            hasNext(), next(), hasPrevious(), previous(),
                                                                           nextIndex(), previousIndex(), set(E e), add(E e)

******************************************************************************************************************************************************************************************


12) what is the purpose of java.util.concurrent package

The package includes thread-safe variants of commonly used collections, such as:

ConcurrentHashMap: A thread-safe version of HashMap that allows concurrent access and modifications without blocking the entire map.


It provides several synchronization constructs, such as:

Locks: The Lock interface and its implementations (like ReentrantLock) offer more flexible locking mechanisms than the traditional
synchronized methods/blocks.

Condition Variables: Condition objects allow threads to wait for specific conditions and notify others when conditions change, 
enhancing the synchronization capabilities.


******************************************************************************************************************************************************************************************

13) How does exception propagate throughout the java code




******************************************************************************************************************************************************************************************
14) What is Java EE

Java EE, or Java Platform, Enterprise Edition, is a set of specifications and standards that extend the Java SE (Standard Edition) 
to provide a robust platform for developing large-scale, distributed, multi-tiered enterprise applications. 

J2EE, now known as Java Enterprise Edition (Java EE) and later Jakarta EE, is a Java-based platform and collection of APIs 
and protocols designed for developing and deploying scalable, robust, and secure enterprise-level applications. 

******************************************************************************************************************************************************************************************

15) Difference between thread and process


Threads and processes are fundamental concepts in operating systems and concurrent programming, 
but they serve different purposes and have distinct characteristics. 


Feature	                                   Process	                                                Thread
Definition	                               Independent program in execution	           Smallest unit of processing within a process
Memory Allocation	                        Separate memory space	                      Shares memory space with other threads
Overhead                                 	Higher overhead (creation/management)	      Lower overhead (creation/management)
Isolation	                                Isolated from other processes	              Not isolated; can affect each other
Life Cycle	                               More complex life cycle                          	Simpler life cycle
Use Cases	                                Suitable for isolated tasks	               Suitable for concurrent tasks


******************************************************************************************************************************************************************************************

16) Synchronized and volatile keyword :-

The synchronized modifier is only for methods and blocks not for variables and classes. Synchronized keyword comes into the 
picture when multiple threads are trying to get access to the same java object simultaneously. A synchronized block or method 
allows only one thread at a time to execute on a given object, which will solve the problem of data inconsistency.
To use synchronized keywords in Java we have two ways 1) Synchronized method 2) Synchronized block


A volatile keyword is a field modifier that provides a visibility guarantee. Java uses volatile as an indicator to the Java 
compiler and thread that does not cache the value of this variable and always reads it from the main memory. 
The volatile keyword is only used with variables not with methods or classes.
When a variable is marked as volatile, any read or write to that variable is done directly from the main memory 
(not from thread-local caches).
This ensures that the latest value of the variable is visible to all threads. Without volatile, each thread might
have its own copy of the variable 
in its cache, and changes made by one thread might not be visible to others.
Example:-

class Test
{
boolean flag = true;
}
In the above example, suppose two threads are working on the same class. Both threads run on different processors where each thread has its local copy of the flag. And if any thread changes the value of the flag, in the main memory the value will not get reflected and because the other threads are not aware of the changed value it will lead to data inconsistency.

class Test
{
volatile boolean flag = true;
}
In the above example, we have declared the flag as volatile so that the value of the variable will never be stored in the cache. And all the read and write operations will be done from and to the main memory.

******************************************************************************************************************************************************************************************

17) Priority of threads in java 

Every Java thread has a priority that helps the operating system determine the order in which threads are scheduled. 
You can get and set the priority of a Thread.

MIN_PRIORITY: Specifies the minimum priority that a thread can have. 1

NORM_PRIORITY: Specifies the default priority that a thread is assigned. 5

MAX_PRIORITY: Specifies the maximum priority that a thread can have. 10

******************************************************************************************************************************************************************************************

18) Context switching in java

Thread Context Switch is a process of switching the working from one thread to another. The computer CPU stores the state of current 
thread, so that it can be retured later. Next it switches to the next thread, picks it where it was left before, and continuous to 
start working.

******************************************************************************************************************************************************************************************

19) sleep() and wait()

While the sleep() function is time-dependent and doesn't need any notice, the wait() method is time-independent and requires
notification from another thread. 

sleep --> does not releases lock on resource  
wait --> releases lock on resource 


******************************************************************************************************************************************************************************************

20) What is an atomic object

In Java, an atomic object typically refers to an object that provides atomic operations, ensuring that operations on it are completed
without interference, particularly in multi-threaded environments. The java.util.concurrent.atomic package provides classes like 
AtomicInteger, AtomicLong, AtomicReference, etc., which allow atomic operations on single variables.

In Java, atomic operations are generally provided by the java.util.concurrent.atomic package, which includes classes designed to 
safely manipulate variables in a multithreaded environment.

Key Concepts:
Atomic Variables: These are variables for which atomic operations (such as read, write, increment, etc.) are provided without needing synchronization.
Atomic Classes: Java provides several atomic classes, such as AtomicInteger, AtomicLong, AtomicReference, etc., to handle variables atomically.
These atomic classes provide a higher-level alternative to using synchronized blocks or methods for thread safety.

Atomic Classes in Java
AtomicInteger: Provides atomic operations for an int value.
AtomicLong: Provides atomic operations for a long value.
AtomicBoolean: Provides atomic operations for a boolean value.
AtomicReference: Provides atomic operations for an object reference.


******************************************************************************************************************************************************************************************

21) Optional class


Every Java Programmer is familiar with NullPointerException. It can crash your code. And it is very hard to avoid it without using too many null checks.
So, to overcome this, Java 8 has introduced a new class Optional in java.util package. It can help in writing a neat code without using too many null checks. 
Optional is a container object which may or may not contain a non-null value. You must import java.util package to use this class. If a value is present,
isPresent() will return true and get() will return the value.

of: It makes an optional with a non-null value
empty: It makes an empty optional
ofNullable: It makes an optional with a nullable value
get: It receives the value if present; if not, then it delivers an exception, i.e., NoSuchElementException
orElseGet: It returns the value if present; if not, it returns the result of invoking the supplier function.
orElse: It returns the value if present; if not, then it returns the given default value
orElseThrow: It returns the value if present; if not, then it delivers an exception produced by the given supplier



******************************************************************************************************************************************************************************************

22) Lambda expressions

Lambda expressions in Java, introduced in Java SE 8, represent instances of functional interfaces (interfaces with a single abstract method). 
They provide a concise way to express instances of single-method interfaces using a block of code.


Lambda expressions are a way to write anonymous functions in Java, making your code shorter and more expressive—especially 
when working with collections and functional interfaces.

Functionalities of Lambda Expression
Lambda Expressions implement the only abstract function and therefore implement functional interfaces lambda expressions are added in Java 8 and provide the below functionalities.

Functional Interfaces(Single Abstract Method (SAM)): A functional interface is an interface that contains only one abstract method.
Code as Data: Treat functionality as a method argument.
Class Independence: Create functions without defining a class.
Pass and Execute: Pass lambda expressions as objects and execute on demand.

@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);  // Single abstract method (SAM)
}

public class LambdaExample {
    public static void main(String[] args) {
        // Using lambda to implement the MathOperation interface
        MathOperation add = (a, b) -> a + b;
        MathOperation subtract = (a, b) -> a - b;

        System.out.println("Addition: " + add.operate(5, 3));        // Output: 8
        System.out.println("Subtraction: " + subtract.operate(5, 3)); // Output: 2
    }
}

import java.util.*;

public class LambdaExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Alice", "Bob", "Charlie");

        // Sort names by length using a lambda expression
        Collections.sort(names, (a, b) -> a.length() - b.length());

        System.out.println(names);  // Output: [Bob, John, Alice, Charlie]
    }
}

public class LambdaExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);

        // Square each number and then sum them using map() and reduce()
        int sumOfSquares = numbers.stream()
                                  .map(n -> n * n)               // Square each number
                                  .reduce(0, (a, b) -> a + b);   // Sum them up

        System.out.println("Sum of squares: " + sumOfSquares);  // Output: 30
    }
}

******************************************************************************************************************************************************************************************

23) User defined Marker interfaces

In Java, a marker interface is an interface that does not contain any methods. Its primary purpose is to signal to the JVM or a framework that the implementing class 
possesses certain properties or capabilities. Marker interfaces are often used for metadata tagging to provide additional information about a class without modifying
its behavior directly.

Key Points about Marker Interfaces:
A marker interface does not declare any methods.
It is used to tag or mark a class for special treatment by the JVM or libraries.
The presence of the interface is checked by the program at runtime, usually with the instanceof operator, or by using reflection.
Marker interfaces help achieve a form of type checking.


public class MarkerInterfaceExample {
    public static void main(String[] args) {
        UserData user = new UserData("Alice", 25);

        // Check if the object is an instance of the Serializable interface
        if (user instanceof Serializable) {
            System.out.println("UserData is serializable");
        } else {
            System.out.println("UserData is not serializable");
        }
    }
}

Marker interfaces are interfaces that don’t contain methods but are used to provide metadata or to tag a class for special processing.
You can create your own custom marker interfaces to indicate that certain behavior should be applied to the marked classes.
They are often used for purposes like serialization, cloning, security checks, and threading.


public class ValidationExample {
    public static void main(String[] args) {
        User user = new User("Alice", 25);

        // Check if the class is validatable --> it is just a no method user defined interface.If object is instance of validatable then it should perform or implement or pass the
mentioned validations.
        if (user instanceof Validatable) {
            System.out.println("Validating user: " + user.getName());
            // Perform validation (for example, checking if age is valid)
            if (user.getAge() < 18) {
                System.out.println("User is not valid.");
            } else {
                System.out.println("User is valid.");
            }
        } else {
            System.out.println("User is not validatable.");
        }
    }
}



******************************************************************************************************************************************************************************************


24) Equals() and hashCode() methods (Significance & Best Practices)

The equals() and hashCode() methods in Java are fundamental for working with collections, ensuring object comparison consistency,
and providing effective hashing mechanisms.


Significance of equals() and hashCode()

equals() Method:

The equals() method is used to compare two objects for logical equality.
By default, the equals() method in the Object class compares object references (i.e., checks if two objects are the same in memory).
When you override equals(), you're telling Java how to compare the contents or attributes of two objects.

hashCode() Method:

The hashCode() method provides a unique integer (hash code) representation of an object.
It is used in hashing algorithms to efficiently store and retrieve objects in collections like HashMap, HashSet, and Hashtable.
The hashCode() method ensures that objects that are logically equal (i.e., equals() returns true) must have the same hash code.

When you override equals(), you must also override hashCode() to maintain the general contract between them. 


When comparing objects in equals(), use instanceof to ensure you're comparing objects of the correct type. This avoids ClassCastException
Best Practices for Overriding equals() and hashCode()

Override both methods:

Whenever you override equals(), also override hashCode() to maintain the contract. Failing to do so may result in inconsistent
behavior in hash-based collections.

Use the @Override annotation:

Always use the @Override annotation to ensure you're overriding the correct methods, which also improves code readability and reduces errors.


instanceof is a keyword used in Java to check if an object is an instance of a specific class or subclass. 
It returns true if the object is of the specified type or a type that inherits from it, and false otherwise.

The getClass() method is a method of the Object class, and every Java object inherits it.
It returns the runtime class of the object, i.e., the exact type of the object at the moment.

******************************************************************************************************************************************************************************************


Object Cloning (Shallow Copy vs Deep Copy)

Cloning means creating a copy of an object in Java.

Shallow Copy: Only the outer object is copied. If the object has other objects inside it (like an address or list), those inner objects 
are not copied; they are just shared between the original and the copy.

 @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();  // Shallow copy (does not copy address)
    }

Deep Copy: Both the outer object and all the inner objects are completely copied. The original and the copied object don’t share anything.

  @Override
    public Object clone() throws CloneNotSupportedException {
        // Deep copy: Clone the Address object as well
        Person clonedPerson = (Person) super.clone();
        clonedPerson.address = (Address) address.clone();  // Deep copy for Address
        return clonedPerson;
    }


The Cloneable interface is a marker interface in Java, meaning it doesn't contain any methods. 
The purpose of this interface is to indicate that an object can be cloned using the clone() method.
If a class does not implement Cloneable, calling the clone() method on its object will throw a CloneNotSupportedException.

If you want to clone an object of a custom class, that class must implement Cloneable.
By default, clone() performs a shallow copy (it only copies the object itself, not the objects it refers to).
If you want a deep copy (where nested objects are cloned as well), you need to override the clone() method (method in Object class) in your 
class and implement the deep cloning logic.

----> super.clone() to perform the default cloning

******************************************************************************************************************************************************************************************

Aspect	                        Tight Coupling	                                                 Loose Coupling

Dependency	                 Strong dependency between classes.	                         Minimal or no direct dependency.
Flexibility	                Hard to modify without affecting other components.	         Easier to modify and extend.
Maintainability	            Difficult to maintain and refactor.                        	Easier to maintain and refactor.
Testability	                Difficult to test in isolation.                            	Easier to test individual components.
Reusability	                Difficult to reuse classes independently.	                  Easier to reuse classes independently.



class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine = new Engine(); // Tight coupling

    public void drive() {
        engine.start();
        System.out.println("Car is driving");
    }
}



interface Engine {
    void start();
}

class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol engine started");
    }
}

class ElectricEngine implements Engine {
    public void start() {
        System.out.println("Electric engine started");
    }
}

class Car {
    private Engine engine;

    public Car(Engine engine) {
        this.engine = engine; // Loose coupling through dependency injection
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving");
    }
}

******************************************************************************************************************************************************************************************


SOLID Principles in Java

The SOLID principles are a set of design principles that help developers create more maintainable, flexible, and scalable software. 
They are particularly useful in object-oriented programming (OOP) and are often used in Java development. 


1. Single Responsibility Principle (SRP)
Definition: A class should have only one reason to change, meaning it should have only one responsibility or job.
In Java: If a class is responsible for multiple unrelated tasks, it becomes harder to maintain. 
You should refactor such classes into smaller, focused classes, each handling one responsibility.

2. Open/Closed Principle (OCP)
Definition: Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
In Java: You should be able to add new functionality to a class without modifying its existing code. 
This is often achieved using inheritance or interfaces.

interface Shape {
    double area();
}

class Circle implements Shape {
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    public double area() { return Math.PI * radius * radius; }
}

class Rectangle implements Shape {
    private double width, height;
    public Rectangle(double width, double height) { this.width = width; this.height = height; }
    public double area() { return width * height; }
}

class AreaCalculator {
    public double calculateArea(Shape shape) { //recieves specific shape implementation in constructor --> dependency injection
        return shape.area();
    }
}

3. Liskov Substitution Principle (LSP)
Definition: Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.
In Java: A subclass should be able to substitute a superclass object without altering the desired behavior of the program. 
This means the subclass should honor the behavior expected of the superclass.



class Bird {
    public void fly() { System.out.println("Flying"); }
}

class Sparrow extends Bird {
    public void fly() { System.out.println("Sparrow flying"); }
}

class Penguin extends Bird {
    // Violates LSP because penguins can't fly, which breaks expected behavior
    public void fly() { throw new UnsupportedOperationException("Penguins can't fly!"); }
}
solution :-

// Base class for all birds
class Bird {
    public void eat() {
        System.out.println("Eating");
    }
}

// A subclass for birds that can fly
class FlyingBird extends Bird {
    public void fly() {
        System.out.println("Flying");
    }
}

// A specific bird that can't fly
class Penguin extends Bird {
    public void swim() {
        System.out.println("Swimming");
    }
}

// A subclass of FlyingBird (can fly)
class Sparrow extends FlyingBird {
    @Override
    public void fly() {
        System.out.println("Sparrow is flying");
    }
}

public class LSPCompliantExample {
    public static void main(String[] args) {
        Bird bird = new Sparrow();
        ((FlyingBird) bird).fly();  // This works fine

        Penguin penguin = new Penguin();
        penguin.swim();  // Penguin swims, but no fly method here
    }
}


4. Interface Segregation Principle (ISP)
Definition: Clients should not be forced to depend on interfaces they do not use.
In Java: Instead of having a large, all-encompassing interface, you should break it into smaller, more specific interfaces. 
This way, classes implement only the methods that are relevant to them.



interface Animal {
    void eat();
    void sleep();
    void fly();
}

class Dog implements Animal {
    public void eat() { /* Dog eating */ }
    public void sleep() { /* Dog sleeping */ }
    public void fly() { throw new UnsupportedOperationException("Dogs can't fly!"); }
}

The above violates ISP because the Dog class is forced to implement the fly() method, which it doesn't need. 

interface Animal {
    void eat();
    void sleep();
}

interface Flyable {
    void fly();
}

class Dog implements Animal {
    public void eat() { /* Dog eating */ }
    public void sleep() { /* Dog sleeping */ }
}

class Bird implements Animal, Flyable {
    public void eat() { /* Bird eating */ }
    public void sleep() { /* Bird sleeping */ }
    public void fly() { /* Bird flying */ }
}

5. Dependency Inversion Principle (DIP)
Definition: High-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore, 
abstractions should not depend on details. Details should depend on abstractions.
In Java: The idea is to decouple high-level business logic from low-level details (like specific implementations) 
using interfaces or abstract classes. This can be achieved through techniques like dependency injection.


class LightBulb {
    public void turnOn() { System.out.println("LightBulb turned on"); }
    public void turnOff() { System.out.println("LightBulb turned off"); }
}

class Switch {
    private LightBulb bulb;
    public Switch(LightBulb bulb) { this.bulb = bulb; }

    public void operate() {
        // simple dependency, tightly coupled
        bulb.turnOn();
    }
}
This design violates DIP because Switch depends directly on the LightBulb. To follow DIP, we can introduce an abstraction (interface):

interface Switchable {
    void turnOn();
    void turnOff();
}

class LightBulb implements Switchable {
    public void turnOn() { System.out.println("LightBulb turned on"); }
    public void turnOff() { System.out.println("LightBulb turned off"); }
}

class Switch {
    private Switchable device;
    public Switch(Switchable device) { this.device = device; }

    public void operate() {
        device.turnOn();
    }
}

******************************************************************************************************************************************************************************************

CopyOnWriteArrayList :-

CopyOnWriteArrayList is a class in Java that belongs to the java.util.concurrent package and is a part of the Java Collections framework.
It is a thread-safe variant of the ArrayList. The key feature of CopyOnWriteArrayList is that it handles concurrency by making a 

fresh copy of the underlying array whenever a modification (such as adding or removing elements) occurs.

Concurrency: It's thread-safe, but the trade-off is the performance overhead of copying the array for write operations.
Ideal Usage: Best suited for applications with a lot of reads and fewer writes.
No Synchronization Needed: No external synchronization is required when using CopyOnWriteArrayList because it ensures thread safety internally.


As the name indicates, CopyOnWriteArrayList creates a Cloned copy of underlying ArrayList, for every update operation at a certain point both will be synchronized automatically, which is taken care of by JVM. Therefore, there is no effect for threads that are performing read operation.
It is costly to use because for every update operation a cloned copy will be created. Hence, CopyOnWriteArrayList is the best choice if our frequent operation is read operation.
The underlined data structure is a grow-able array.
It is a thread-safe version of ArrayList.
Insertion is preserved, duplicates, null, and heterogeneous Objects are allowed.
The main important point about CopyOnWriteArrayList is the Iterator of CopyOnWriteArrayList can not perform remove operation otherwise we get Run-time exception saying 
UnsupportedOperationException. add() and set() methods on CopyOnWriteArrayList iterator also throws UnsupportedOperationException. Also Iterator of CopyOnWriteArrayList
will never throw ConcurrentModificationException.

******************************************************************************************************************************************************************************************


Fail-Fast vs Fail-Safe Collections


In the context of programming and data structures, Fail-Fast and Fail-Safe refer to different approaches in how collections
(like lists, sets, or maps) behave when they are modified while being iterated over. 

Fail-Fast Collections
Definition: A collection is considered "fail-fast" when it immediately throws an exception if it detects that it has been structurally modified (i.e., changed in terms of adding or removing elements) while it is being iterated over.
Behavior: If an iterator is actively traversing a collection and the collection is modified (such as by adding or removing elements), the collection will throw a ConcurrentModificationException (in Java, for example) to signal that something has gone wrong.
Advantages:
Helps detect errors early, making them easier to debug.
Prevents undefined behavior or incorrect results when working with multi-threaded programs or when modifying the collection during iteration.
Disadvantages:
The program may throw exceptions unexpectedly during iteration if the collection is modified.
Requires developers to handle concurrent modifications carefully, typically with synchronization or locks.


List<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);

Iterator<Integer> iterator = list.iterator();
list.add(3);  // This will cause ConcurrentModificationException during iteration
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}


Fail-Safe Collections
Definition: A collection is considered "fail-safe" when it doesn’t throw exceptions if it is modified during iteration. Instead, fail-safe collections allow the iteration to continue and typically work on a copy or snapshot of the data.
Behavior: Fail-safe collections use a copy or snapshot mechanism to avoid issues with structural modifications. Even if the collection is modified during iteration (either by adding or removing elements), the iteration process continues over the original state of the collection, unaffected by the changes.
Advantages:
It avoids exceptions, which can be beneficial in some cases, particularly in concurrent systems where you may expect modifications during iteration.
Makes iteration easier in multithreaded environments, as it doesn't require explicit synchronization.
Disadvantages:
Can introduce overhead, as collections may create copies of themselves during iteration, leading to increased memory usage and potentially slower performance.
The behavior can be unpredictable if you expect changes to be reflected during iteration, as you are iterating over a snapshot of the collection at a given point in time.

List<Integer> list = new CopyOnWriteArrayList<>();
list.add(1);
list.add(2);

Iterator<Integer> iterator = list.iterator();
list.add(3);  // No ConcurrentModificationException, the iteration continues normally
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}

Conclusion:
Fail-Fast collections are ideal when you want to quickly detect and fix problems with concurrent modifications in a collection. 
However, they require careful management of how and when modifications happen during iteration.
Fail-Safe collections are more tolerant and safe for concurrent modifications but may come with performance trade-offs due to 
the overhead of copying the collection.


******************************************************************************************************************************************************************************************

ConcurrentHashMap & Its Working

A ConcurrentHashMap is a part of Java's java.util.concurrent package, and it is a thread-safe, high-performance map implementation 
that allows concurrent access to its elements by multiple threads without the need for external synchronization.

Key Features of ConcurrentHashMap:

Thread Safety: Unlike a regular HashMap, ConcurrentHashMap ensures that concurrent read and write operations can be performed 
safely by multiple threads without corrupting the underlying data.

Locking Mechanism:
It uses a bucket-level locking mechanism (also known as segment locking) instead of locking the entire map like Hashtable does. This enables multiple threads to access different segments of the map concurrently.
The map is divided into multiple segments (buckets), and each segment can be locked independently when modifications are being made.
This reduces contention and increases the throughput.

Non-blocking Reads:
Reads do not require locking, so multiple threads can read from the map simultaneously without any performance degradation.
Atomic Operations: Operations like putIfAbsent(), remove(), and replace() are atomic and thread-safe.

Concurrency Levels:
You can specify the number of concurrent segments when creating a ConcurrentHashMap (default is 16), allowing you to control 
the granularity of the locking.

How It Works:
Internally, ConcurrentHashMap is divided into segments. Each segment is essentially a smaller hash map with its own locks. This approach minimizes the contention on the entire map, as different threads may work on different segments simultaneously.

Here is how the basic operations work in ConcurrentHashMap:

Read Operation:
A read operation is non-blocking. Multiple threads can read from different segments at the same time without locking.
Write Operation:
A write operation requires locking the segment that the key belongs to. But since different segments can be locked independently, 
other threads can still write to other segments concurrently.
Update Operations (like putIfAbsent(), replace(), etc.):
These operations are atomic. If multiple threads try to update the same key, one will succeed, and the others will fail gracefully.

In summary, ConcurrentHashMap is an excellent choice when you need a high-performance, thread-safe map that allows concurrent 
access without requiring external synchronization. Its fine-grained locking mechanism helps achieve better concurrency and 
throughput in multi-threaded applications.

******************************************************************************************************************************************************************************************

Java 8 Features (Most Asked in Interviews)

1. Lambda Expressions
2. Functional Interfaces
3. Stream API
4. Default Methods --> Java 8 allows interfaces to have default methods with implementation. This helps in adding new methods to interfaces without 
                       breaking existing implementations.
5. Method References
6. Optional Class
7. Parallel Streams

******************************************************************************************************************************************************************************************


Predicate, Consumer, Supplier, Function 

In Java 8, the java.util.function package introduced several functional interfaces, including Predicate, Consumer, Supplier, and Function.
These are essential for functional programming in Java and are commonly used in lambda expressions and streams. 

1. Predicate<T>
A Predicate is a functional interface that represents a condition or boolean test. It takes an argument of type T and returns
a boolean value (true or false).

Signature: boolean test(T t)
Use Case: It is often used for filtering data in streams or conditions where you need to evaluate whether a condition is true or false.

Predicate<String> isLengthGreaterThan3 = str -> str.length() > 3;

System.out.println(isLengthGreaterThan3.test("Java"));  // true
System.out.println(isLengthGreaterThan3.test("Hi"));    // false


2. Consumer<T>
A Consumer represents an operation that takes a single input of type T and returns no result.
It is typically used for performing an action (side effect) such as printing, modifying values, etc.

Signature: void accept(T t)
Use Case: It’s often used for operations that modify an object, print to the console, or have some other side effect.

Consumer<String> printUpperCase = str -> System.out.println(str.toUpperCase());

printUpperCase.accept("hello");  // Output: HELLO

Common Methods:
andThen(Consumer<? super T> after) (to chain multiple consumers)

3. Supplier<T>
A Supplier represents a supplier of results. It doesn't take any arguments but returns a value of type T. 
It's typically used when you want to generate or provide values, like generating random numbers, or providing default values.

Signature: T get()
Use Case: It’s often used when you want to generate or supply an object but don't need any input.

Supplier<String> provideString = () -> "Hello, World!";

System.out.println(provideString.get());  // Output: Hello, World!

4. Function<T, R>
A Function represents a function that takes an argument of type T and produces a result of type R. 
It is used for transformation or mapping operations.

Signature: R apply(T t)
Use Case: It’s useful for converting or mapping one type of object into another, such as converting strings to 
integers or transforming a list of objects.

Function<String, Integer> stringLength = str -> str.length();

System.out.println(stringLength.apply("Hello"));  // Output: 5



******************************************************************************************************************************************************************************************

 Starvation & Race Conditions

1. Starvation
Starvation happens when a thread (a unit of work in your program) doesn't get a chance to run. 
It’s like a thread waiting for its turn forever, while other threads are constantly getting priority and never letting it run.

Example: Imagine you have several workers (threads), but some workers are always getting tasks (CPU time), 
while others are kept waiting and never get a chance to work.

How to avoid it:

Make sure that threads get a fair chance to run by using fair locks or setting up thread priorities correctly.

2. Race Condition
A race condition occurs when two or more threads try to access and change the same data at the same time. 
This can cause problems because the threads might interfere with each other and give wrong results.

Example: Imagine two people trying to update a bank account balance at the same time without checking each other’s work.
One person could overwrite the other’s changes, causing an incorrect balance.

How to avoid it:

Make sure only one thread can access or modify shared data at a time. You can do this by using synchronized blocks or
using special classes like AtomicInteger which handle thread safety automatically.

Key Differences:
Starvation is about a thread being ignored and never getting a chance to run.
Race Condition happens when threads mess with shared data at the same time and mess things up.


******************************************************************************************************************************************************************************************


Java Class Loading Mechanism & ClassLoader Hierarchy


In Java, class loading refers to the process by which Java runtime environment (JRE) loads the classes needed for the program to run.
The class loading mechanism is part of the Java Runtime Environment (JRE) that loads, links, and initializes classes.

Here’s a breakdown of how class loading works in Java:

Class Loader (JVM Class Loading): The class loader is responsible for loading class files from the file system or network into the
Java Virtual Machine (JVM). When you run a Java program, the JVM doesn't know where the classes are located initially, so it relies 
on the class loader to locate and load classes dynamically into memory.

Class Loading Process:

Loading: When a class is first referenced, the class loader looks for the corresponding .class file (bytecode) on the local 
file system, a network resource, or another source.
Linking: This involves verification (checking bytecode for validity), preparation (assigning memory for static variables),
and optional resolution (substituting symbolic references with actual references).
Initialization: After a class has been loaded and linked, it is initialized, which involves executing static blocks, 
initializing static variables, and preparing the class for use.

ClassLoader Hierarchy

The class loader hierarchy in Java is structured as a tree, with multiple class loaders that form a chain of responsibility. 
There are three major class loaders:

Bootstrap ClassLoader (Primordial ClassLoader):

The Bootstrap ClassLoader is the parent of all class loaders in Java and is part of the core Java runtime environment.
It loads core Java classes, such as those in the java.lang, java.util, java.net, and other fundamental packages, from the 
Java Runtime Environment (JRE).
The classes it loads are typically stored in the rt.jar (or similar file) in the JRE.

Extension ClassLoader (Platform ClassLoader):

The Extension ClassLoader is responsible for loading classes from the JDK extension directory (jre/lib/ext) or any custom classpath 
specified.
It loads classes related to standard Java extensions (such as JDBC, JCE) that extend the functionality of the core Java platform.


System/Application ClassLoader (User ClassLoader):

The System ClassLoader, also known as the Application ClassLoader, is responsible for loading classes that are part of the classpath of your application.
It loads classes from locations such as the classpath (including .jar files or directories). This is the default class loader for most user applications.
It is the one typically responsible for loading the classes specified when running the program via the java -cp command.
ClassLoader Hierarchy in Java
The class loader hierarchy follows a parent-child relationship:

Bootstrap ClassLoader (parent to all class loaders) -> It cannot be directly instantiated.
Extension ClassLoader (child of Bootstrap ClassLoader) -> Responsible for loading classes from the JDK extensions.
System/Application ClassLoader (child of Extension ClassLoader) -> Responsible for loading application-level classes.
When a class is requested, the class loader first delegates the request to its parent. If the parent class loader can’t find the class, it will load the class itself.

Example:
If an application class A needs to load class B, the following hierarchy applies:

ClassLoader for class A will first delegate the request to its parent class loader (which could be the system class loader or the extension class loader).
If the parent class loader doesn't find the class, the current class loader will try to load it itself.
If none of the class loaders can find it, a ClassNotFoundException will be thrown.
Custom ClassLoader in Java
Java allows you to create custom class loaders by extending the ClassLoader class. This is particularly useful when:

Loading classes from non-standard locations (like databases, network resources).
Implementing a special class loading behavior (like reloading classes in a hot-swapping application).
A custom class loader can override the findClass method to load classes from custom sources.


******************************************************************************************************************************************************************************************

.war file into .jar to run 

Steps:
1. Extract the contents of the .war file
A .war file is just a ZIP file, so you can extract it like any other compressed file.

Windows: Use a tool like WinRAR or 7-Zip to extract the .war file.

Linux/Mac: Use the unzip command in the terminal:

bash
Copy
unzip yourfile.war -d yourfolder
This will extract all the contents (web resources, classes, etc.) of the .war file into the folder yourfolder.

2. Add a Main-Class entry for the .jar file
A .war file doesn't have an entry point (i.e., it lacks a main method). To turn it into a .jar file that you can run, you'll need to add a class with a main method.

Create a file called MainClass.java (or any name you prefer) in the extracted folder (yourfolder).

Inside MainClass.java, add the following code. For simplicity, this code assumes you're using an embedded server like Jetty or a basic entry point to run the application:

java
Copy
public class MainClass {
    public static void main(String[] args) {
        // Simple code to run a web server (like Jetty, Tomcat, etc.)
        // If it's a Spring Boot app, you can start it here as well.
        
        System.out.println("Running your .war as a .jar");
        // Your code to start the application goes here.
    }
}
3. Recompile the Java file (if needed)
If you added or modified any Java files, compile them using the javac command.

For example:

bash
Copy
javac -d . MainClass.java
This will compile MainClass.java and place the .class files in the same directory.

4. Create a MANIFEST.MF file
This file tells Java which class to run when the .jar is executed. You'll need to create a MANIFEST.MF file inside the META-INF folder in the extracted .war folder.

Create the following structure if it doesn’t already exist:

Copy
META-INF/
  MANIFEST.MF
Inside MANIFEST.MF, add this content:

makefile
Copy
Manifest-Version: 1.0
Main-Class: MainClass
Make sure to replace MainClass with the name of your class if you used a different name.

5. Repackage everything into a .jar file
Now that you've added the Main-Class and ensured your Java files are compiled, you can repackage everything into a .jar.

Run the following jar command:

bash
Copy
jar cmf META-INF/MANIFEST.MF your_new_file.jar -C yourfolder .
This command will:

Use the MANIFEST.MF file located in the META-INF folder to specify the main class.
Create a new .jar file named your_new_file.jar containing all files in the yourfolder directory.
6. Run the .jar file
Once the .jar file is created, you can run it with the following command:

bash
Copy
java -jar your_new_file.jar
If everything is set up correctly, your .war will now run as a .jar file!



*****************************************************************************************************************************************************************************************

agile methodologies

Agile methodologies are a set of principles and practices for software development that emphasize flexibility, collaboration, 
and customer feedback. These methodologies aim to deliver working software frequently and iteratively, allowing teams to adapt 
to changes quickly and efficiently.


Key Agile Frameworks and Practices:

Scrum:

Roles: Product Owner, Scrum Master, Development Team.
Artifacts: Product Backlog, Sprint Backlog, Increment.
Events: Sprint, Sprint Planning, Daily Scrum, Sprint Review, Sprint Retrospective.
Focus: Short development cycles called Sprints (usually 2-4 weeks). Scrum emphasizes transparency, inspection, and adaptation.


Kanban:

Kanban Board: At the heart of Kanban is the visual representation of the workflow. This is typically a Kanban board, 
where work items are represented by cards and are placed in columns that represent the stages of the process (e.g., "To Do," "In Progress," "Done").
This visualization helps teams see where tasks are in the workflow and identifies any bottlenecks or areas needing attention.

Limiting WIP helps teams focus on completing tasks before starting new ones. 
This ensures that work flows smoothly without overloading the team. 


Kanban vs. Scrum:
Scrum uses fixed-length sprints, while Kanban focuses on continuous flow of work without the constraints of timeboxed iterations.
Scrum has specific roles (Product Owner, Scrum Master, Development Team) and ceremonies (Daily Standups, Sprint Planning, etc.),
whereas Kanban is more lightweight, with no required roles or ceremonies.
In Scrum, teams work on a set number of items in a sprint, while in Kanban, work is pulled as needed, and the focus is on 
completing tasks as efficiently as possible.


Extreme Programming (XP):

Extreme Programming (XP) is a software development methodology within the Agile framework that emphasizes technical excellence,
collaboration, and delivering high-quality software rapidly. It's designed to improve software quality and responsiveness to
changing customer requirements through frequent releases and close collaboration between developers and customers.


Lean Software Development:


Lean Software Development helps teams focus on what truly matters, deliver value quickly, and eliminate unnecessary work.
It encourages continuous improvement, faster feedback, and building quality software from the start.


Feature-Driven Development (FDD):

Feature-Driven Development (FDD) is a software development methodology that focuses on building and delivering software 
features in a structured, systematic way. It is part of the Agile family of methods, but it is more specific in its approach,
emphasizing the development of well-defined features.

The 5 Basic Steps of FDD:
Develop an Overall Model: The team creates a high-level design or model of the software system. 
This helps everyone understand how different parts of the system interact and ensures the architecture supports the features.

Build a Feature List: A list of features is created based on the model. Each feature is described in a simple, user-friendly 
way, and this list becomes the foundation of the work to be done.

Plan by Feature: The features are prioritized and planned. Each feature will be assigned to a team and worked on in short iterations. 
This makes sure that work is focused on delivering value to the customer.

Design by Feature: In this phase, the feature is broken down into more detail, and design work is done to define how the feature
will be implemented.

Build by Feature: The feature is then developed, tested, and delivered. Once a feature is completed, it is integrated into the 
overall system, and the team moves on to the next feature.




Benefits of Agile:

Faster time-to-market: Frequent releases provide working software quicker.
Improved collaboration: Emphasis on communication between developers, customers, and stakeholders.
Better quality: Continuous testing, feedback, and improvement processes lead to high-quality software.
Adaptability: Agile methodologies allow teams to respond to changes in customer needs, technology, or requirements.

Challenges of Agile:

Requires experienced teams: Agile methods can be difficult to implement without the right knowledge and discipline.
Scope creep: If not managed properly, the flexible nature of Agile can lead to uncontrolled changes and feature creep.
Requires customer involvement: Continuous feedback is essential, so active customer participation is needed.



Sure! Agile methodology is a way of managing projects—especially software development—by breaking them down into smaller,
manageable chunks called *iterations* or *sprints* (usually 1–4 weeks long).
Here’s a brief overview:
- **Iterative & Incremental**: Agile delivers work in small increments, allowing teams to adapt quickly to change.
- **Customer Collaboration**: Frequent feedback from stakeholders ensures the product aligns with customer needs.
- **Cross-functional Teams**: Developers, testers, designers, and product owners work closely together.
- **Emphasis on Working Software**: More focus on delivering functional software than heavy documentation.
- **Adaptive to Change**: Agile welcomes changing requirements, even late in development.
- **Popular Frameworks**: Scrum, Kanban, and XP (Extreme Programming) are popular agile approaches.

In Agile—especially in **Scrum**, which is one of the most popular frameworks—there are several key meetings 
(also called **ceremonies**) that help keep the team aligned and the work transparent. Here are the main ones:
1. **Sprint Planning**  
  - **When**: At the beginning of each sprint  
  - **Purpose**: The team decides what work will be done during the sprint and how it will be achieved.
2. **Daily Stand-up (Daily Scrum)**  
  - **When**: Every day (usually 15 minutes)  
  - **Purpose**: Team members quickly share what they did yesterday, what they’ll do today, and any blockers.
3. **Sprint Review**  
  - **When**: At the end of the sprint  
  - **Purpose**: The team demonstrates the completed work to stakeholders and gets feedback.
4. **Sprint Retrospective**  
  - **When**: After the sprint review, before the next sprint begins  
  - **Purpose**: The team reflects on what went well, what didn’t, and how to improve in the next sprint.
5. **Backlog Refinement (Grooming)** *(optional but recommended)*  
  - **When**: Mid-sprint or as needed  
  - **Purpose**: The team reviews and updates the product backlog—clarifying stories, estimating effort, and prioritizing.

*****************************************************************************************************************************************************************************************

JIRA and confluence

Jira is a project management tool primarily used for issue tracking and project management in software development and other fields. 
It helps teams plan, track, and manage their work, especially in Agile environments.

1. Issues
Issue: An issue in Jira represents a unit of work or a task. It can be anything from a bug to a user story, task, or a feature request.
Issue Types: There are different types of issues in Jira, including:
Bug: A defect or problem in the software.
Story: A piece of work that needs to be completed, often representing a feature or functionality.
Task: A simple, actionable work item.
Epic: A large body of work that can be broken down into smaller stories or tasks.
Sub-task: A smaller work item that is part of a larger issue.
Change Request, Improvement, and others depending on the specific project setup.


2. Projects
Project: A project is a collection of issues and related work within Jira. It can represent a team, initiative, or product.
Project Types: Jira offers different project types like Kanban, Scrum, Basic Software Development, and Business Projects, 
each having specific configurations.

3. Boards
Kanban Board: A visual representation of tasks and their statuses in a workflow, commonly used for teams with continuous delivery cycles.
Scrum Board: A board used by teams working in agile sprints, showing the sprint backlog, ongoing tasks, and completed work.

4. Workflows
Workflow: A sequence of statuses and transitions that an issue goes through during its lifecycle (e.g., "To Do", "In Progress", "Done").
Status: The stage an issue is in, such as "Open," "In Progress," or "Closed."
Transition: The action that moves an issue from one status to another.

5. Sprints
Sprint: A time-boxed period during which a Scrum team works to complete a predefined set of tasks or stories. 
Sprints are often 1-4 weeks long.
Sprint Backlog: A list of issues (stories, tasks, etc.) that the team commits to complete in a specific sprint.

6. Epics and Stories
Epic: A large user story that can be broken down into smaller, more manageable pieces (stories or tasks).
Story: A feature or requirement that can be completed within a single sprint. A story is typically defined using the format
“As a [user], I want [functionality] so that [benefit].”

7. Backlog
Product Backlog: A prioritized list of features, tasks, and bug fixes that need to be completed for the product.
It's typically managed by a Product Owner.
Sprint Backlog: A subset of the product backlog, selected to be worked on during a sprint.



Confluence is a collaboration and documentation tool that allows teams to create, share, and collaborate on content like meeting notes, 
project documentation, knowledge bases, and more.

*****************************************************************************************************************************************************************************************

Callable vs Runnable interface

Runnable and Callable both functional interface. Classes which are implementing these interfaces are designed to be executed
by another thread.In Java, Runnable and Callable are two key interfaces used to represent tasks that can be executed by multiple threads.

Sr. No.   	Key	            Runnable	                                                         Callable
1        Package       It belongs to Java.lang                                       It belongs to java.util.concurrent
2    Thread Creation   We can create thread by passing runnable as a parameter.      We can’t create thread by passing callable as
                                                                                     parameter  
3      Return Type     Ruunable does not return anything                             Callable can return results
4.     Method            It has run() method                                         It has call()method
5    Bulk Execution    It can’t be used for bulk execution of task                   It can be used for bulk execution of task by
                                                                                     invoking invokeAll().

The concurrent API in Java provides a feature known as an executor that initiates and controls the execution of threads. 
As such, an executor offers an alternative to managing threads using the thread class. At the core of an executor is the 
Executor interface. It refers to the objects that execute submitted Runnable tasks. 

Executor Framework & Thread Pooling

The Executor Framework provides a high-level API to manage and control concurrent tasks in Java.
Thread Pooling reduces the overhead of repeatedly creating and destroying threads by reusing a fixed number of threads.
ExecutorService and ThreadPoolExecutor help in managing threads and queues efficiently, improving performance and resource 
management in multithreaded applications.
By leveraging the Executor framework and thread pooling, developers can ensure efficient thread management, 
improve application scalability, and reduce resource overhead.

A Future interface provides methods to check if the computation is complete, to wait for its completion and to retrieve the results of the computation. The result is retrieved using Future’s get() method when the computation has completed, and it blocks until it is completed. 
Future and FutureTask both are available in java.util.concurrent package from Java 1.5.
public class Main {
   public static void main(String args[]) throws InterruptedException, ExecutionException {
      ExecutorService services = Executors.newSingleThreadExecutor();
      Future<?> future = services.submit(new Task());
      System.out.println("In Future Object" + future.get());
   }
}
import java.util.concurrent.Callable;

public class Task implements Callable {

   @Override
   public String call() throws Exception {
      System.out.println("In call");
      String name = "test";
      return name;
   }
}

CompletableFuture is a class in java.util.concurrent package that implements the Future and CompletionStage Interface. 
It represents a future result of an asynchronous computation.
CompletableFuture provides a powerful and flexible way to write asynchronous, non-blocking code. 
It was introduced in Java 8 and has become popular due to its ease of use and ability to handle complex asynchronous workflows.


Executor is the simplest interface for launching a task.-->execute(Runnable)
ExecutorService is a more powerful sub-interface with advanced features like shutting down, submitting tasks for results,
and managing pools.

1. What is ExecutorService?
ExecutorService is a Java interface that helps manage a pool of threads to execute tasks asynchronously (i.e., in the background).
It’s part of java.util.concurrent and is better than manually creating threads using new Thread().
2. Why Use ExecutorService?
Imagine you have 100 tasks to run. Creating 100 threads is heavy and inefficient.
Instead:
• You create a thread pool of 10 threads.
• Submit all 100 tasks.
• The pool reuses those 10 threads to complete the tasks.
This saves system resources and improves performance.
3. How to Create ExecutorService
a. Fixed Thread Pool
ExecutorService executor = Executors.newFixedThreadPool(3);
• Only 3 threads are created.
• If more tasks come in, they wait in a queue.
b. Cached Thread Pool
ExecutorService executor = Executors.newCachedThreadPool();
• Creates new threads as needed.
• Good for many short-lived tasks.
c. Single Thread Executor
ExecutorService executor = Executors.newSingleThreadExecutor();
• Only 1 thread. Tasks are executed one by one.
• Useful when you want to maintain order.
4. Submitting Tasks
a. Runnable (doesn't return result)
executor.submit(() -> {
   System.out.println("Task executed");
});
b. Callable (returns result)
Callable<String> task = () -> {
   Thread.sleep(1000);
   return "Task completed";
};
Future<String> future = executor.submit(task);
String result = future.get();  // Waits for result
System.out.println(result);
5. Shutting Down ExecutorService
You must shut it down after use:
executor.shutdown();  // Graceful shutdown
If you want to stop immediately:
executor.shutdownNow();  // Force shutdown
6. Handling Results: Future
When you submit a Callable, you get a Future<T>:
• get() waits for the result
• isDone() checks if it's finished
• You can also cancel the task using cancel()
7. Real-world Example
Let’s say you’re processing multiple user uploads at once:
ExecutorService executor = Executors.newFixedThreadPool(5);
for (int i = 1; i <= 10; i++) {
   final int fileId = i;
   executor.submit(() -> {
       System.out.println("Uploading file " + fileId);
       // simulate delay
       Thread.sleep(2000);
       System.out.println("Uploaded file " + fileId);
   });
}
executor.shutdown();
8. Summary Table
Feature
Description
submit()
Submit a task (Runnable or Callable)
shutdown()
Graceful shutdown
shutdownNow()
Immediate shutdown
Future<T>
Handle task result and status
FixedThreadPool
Fixed number of threads
CachedThreadPool
Grows and reuses threads as needed
SingleThread
One thread, ordered execution










*****************************************************************************************************************************************************************************************

In **multithreading** and **concurrent programming**, a **semaphore** is a synchronization mechanism used to control access to a shared resource by multiple threads.
It helps prevent **race conditions** and ensures that multiple threads do not access a critical section of code at the same time, which could lead to unpredictable results or errors.

### **Key Concepts of Semaphore:**

1. **Semaphore Basics:**
   A semaphore is essentially a counter that tracks the number of available resources or permits. It can either be **binary** or **counting**:
   - **Binary Semaphore (Mutex):** This is a semaphore with a value of either 0 or 1, used to ensure mutual exclusion (only one thread can access the critical section).
   - **Counting Semaphore:** This allows a range of values, typically representing the number of resources available (e.g., number of identical resources that can be accessed concurrently).

2. **Operations on Semaphores:**
   There are two primary operations that can be performed on a semaphore:
   - **Wait (P or down operation):** This operation checks the semaphore’s value. If the value is greater than 0, it decrements the value and allows the thread to proceed. 
    If the value is 0, the thread is blocked until the semaphore’s value becomes greater than 0.
   - **Signal (V or up operation):** This operation increments the semaphore’s value, signaling that a resource is now available or that a thread has finished using the resource.

3. **Usage in Multithreading:**
   - **Controlling access to shared resources:** When multiple threads need to access shared resources (like a database, printer, or memory), semaphores can limit the number of threads 
     that can access the resource at the same time.
   - **Avoiding race conditions:** By controlling the number of threads accessing a critical section, semaphores help avoid **race conditions** 
     (where the outcome of a program depends on the non-deterministic timing of threads).

### **Example of Semaphore in Multithreading:**

Let’s assume we have a scenario where **3 threads** are trying to access a shared resource, but only **2 threads** can access the resource at a time.
A **counting semaphore** with an initial value of 2 can be used:
Class Name: Semaphore
Package: java.util.concurrent
import java.util.concurrent.Semaphore;

public class SemaphoreExample {

    // Create a semaphore with an initial permit count of 2 (only 2 threads can access the resource at a time)
    private static final Semaphore semaphore = new Semaphore(2);

    public static void main(String[] args) {
        // Create and start 5 threads, but only 2 can access the resource at a time
        for (int i = 0; i < 5; i++) {
            Thread thread = new Thread(new ResourceAccessTask(i));
            thread.start();
        }
    }

    static class ResourceAccessTask implements Runnable {
        private final int threadId;

        public ResourceAccessTask(int threadId) {
            this.threadId = threadId;
        }

        @Override
        public void run() {
            try {
                // Attempt to acquire a permit from the semaphore
                System.out.println("Thread-" + threadId + " is trying to access the resource.");
                semaphore.acquire();  // Wait (decrease the semaphore count)

                // Critical section: Accessing the shared resource
                System.out.println("Thread-" + threadId + " has accessed the resource.");
                Thread.sleep(2000);  // Simulating work with the resource

                // Release the permit (increment the semaphore count)
                semaphore.release();
                System.out.println("Thread-" + threadId + " has released the resource.");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}


### **How This Works:**
- The semaphore is initialized with a value of 2, meaning **only 2 threads** can access the resource simultaneously.
- When a thread calls `semaphore.acquire()`, it decreases the semaphore’s value. If the value is greater than 0, the thread continues; if it’s 0, the thread is blocked until a resource becomes available.
- When the thread finishes using the resource, it calls `semaphore.release()`, which increments the semaphore’s value, allowing another thread to proceed.

### **Why Use Semaphores?**

- **Resource Control:** You can control how many threads can access a resource at the same time, preventing overload or contention for resources.
- **Synchronization:** Semaphores help synchronize threads, ensuring that they cooperate effectively without stepping on each other’s toes.
- **Prevent Deadlocks:** By managing access to shared resources, semaphores can help avoid deadlocks that can occur if threads wait indefinitely for each other.

### **Real-World Example:**
Imagine a **parking lot** with only **3 parking spaces** (resources) available. The **semaphore** would keep track of how many spaces are open.
If there are no spaces left, the **semaphore** would prevent additional cars (threads) from entering until a space becomes free.

---

OOP focuses on building up from smaller, independent components (objects) and then combining them to create a larger, more complex system. 
Upcasting converts a subclass object to its superclass reference, while downcasting converts a superclass reference to its subclass object. 
List<String> syncList = Collections.synchronizedList(new ArrayList<String>());

*****************************************************************************************************************************************************************************************

What are the key differences between String, CharSequence, and StringBuilder?

Definition: CharSequence is an interface that represents a readable sequence of characters. 
It is implemented by String, StringBuilder, and StringBuffer.Does not defines how characters are stored or manipulated.
depends on implementation.

Feature	        String	             CharSequence	              StringBuilder
Type	           Immutable	            Interface	                 Mutable
Thread-Safety	  Thread-safe	  Depends on implementation	      Not thread-safe
Performance	   Slower for 
              modifications   Depends on implementation	    Faster for modifications
Use Case	      Fixed text	
                             Generalized character sequence	Frequent text modifications
Implements	    CharSequence	             —	                      CharSequence

******************************************************************************************************************************************************************************
What is a ClassNotFoundException vs NoClassDefFoundError?


1. ClassNotFoundException
Definition: A checked exception that occurs when an application tries to load a class at runtime using methods
like Class.forName(), ClassLoader.loadClass(), or Class.newInstance(), but the specified class cannot be found.

Cause:
The class is not available in the classpath.
The class file might be missing or incorrectly specified.

When It Happens: At runtime, when the application explicitly tries to load a class dynamically, and the class is not found.

2. NoClassDefFoundError
Definition: An unchecked error that occurs when the Java Virtual Machine (JVM) or a class loader tries 
to load a class during runtime, but the class definition is not available.

Cause:
The class was present during compilation but is missing at runtime.
The class might not be in the runtime classpath or could have been removed or corrupted.
Dependencies of the class are missing (e.g., another class that this class depends on cannot be found).

When It Happens: At runtime, when a class is referenced by code (e.g., creating an instance or calling a static method),
and the definition is not found.
******************************************************************************************************************************************************************************

4. What is the role of the java.lang.Object class and its common methods?

--> Root class of all classes in java
-->Object defines methods that are common to all Java objects, such as toString(), equals(), hashCode(), and more.
   These methods can be overridden by subclasses to provide class-specific behavior.
-->Since Object is the parent of all classes, it allows polymorphism. For example, any object can be assigned
   to a variable of type Object.

toString(),equals(Object obj),hashCode(),getClass(),clone(),finalize(),wait(), notify(), notifyAll()

******************************************************************************************************************************************************************************

Explain generics?


Generics in Java allow you to write code that works with different types while providing compile-time type safety. 
They were introduced in Java 5 to eliminate the need for casting and to help catch type-related errors at compile time.

Why Use Generics?

Without generics:
List list = new ArrayList();
list.add("Hello");
String s = (String) list.get(0);  // Need to cast

With generics:
List<String> list = new ArrayList<>();
list.add("Hello");
String s = list.get(0);  // No need to cast

Benefits of Generics
1 Type Safety – Prevents inserting wrong types into collections.
2 Code Reusability – Write generic algorithms and data structures.
3 Elimination of Casting – No explicit type casting required.
4 Compile-time Checking – Catches errors early.

Generic Class Example
public class Box<T> {
   private T item;
   public void setItem(T item) {
       this.item = item;
   }
   public T getItem() {
       return item;
   }
}
Usage:
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String s = stringBox.getItem();  // No cast needed

Generic Method Example
public <T> void printArray(T[] array) {
   for (T element : array) {
       System.out.println(element);
   }
}

Bounded Type Parameters
Restrict the types that can be used as a type argument.
public <T extends Number> void printDouble(T number) {
   System.out.println(number.doubleValue());
}
Wildcards (?)
Used when you want to allow any type but still maintain some type safety.
• <?> – Unknown type
• <? extends T> – Upper bound
public double sum(List<? extends Number> numbers) {
    double sum = 0.0;
    for (Number num : numbers) {
        sum += num.doubleValue();
    }
    return sum;
}
• <? super T> – Lower bound
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
    list.add(3);
}
public void printList(List<?> list) {
   for (Object obj : list) {
       System.out.println(obj);
   }
}
Limitations :-

1. Generic types are erased at runtime
• Java removes generic type info when your program runs.
• So List<String> and List<Integer> become just List at runtime.
• You can't check type like if (obj instanceof T).
2. Can't use primitives
• You can't use types like int, double in generics.
• You must use wrapper classes like Integer, Double.
List<int> list;    // Not allowed
List<Integer> list; // OK
3. Can't create objects of generic type
You can't do:
T obj = new T();   // Not allowed
4. Can't create generic arrays
This is not allowed:
T[] arr = new T[10];  // Error
5. No method overloading with different generic types
This will cause error:
void print(List<String> list) { }
void print(List<Integer> list) { }  // Not allowed
6. Can't use generics in static members
Because generics depend on objects, not class.
static T value;  // Not allowed
******************************************************************************************************************************************************************************
When to use which data structures:-
Requirement-->Data Structure
Fast lookup by key-->HashMap
Sorted key-value pairs-->TreeMap
Unique elements, fast lookup-->HashSet
Sorted unique elements-->TreeSet
Random access by index-->ArrayList
Fast insert/delete at head-->LinkedList
LIFO (Last-In-First-Out)-->Stack
FIFO (First-In-First-Out)-->Queue
Process by priority-->PriorityQueue

******************************************************************************************************************************************************************************

Java 17 is a Long-Term Support (LTS) release, which means it will receive extended support and updates from Oracle.
It was released in September 2021 and includes several new features and enhancements introduced after Java 11 (the previous LTS).
Here's a list of notable Java 17 features:

1. Sealed Classes (Finalized in Java 17)
• Purpose: Restrict which classes can extend or implement a class or interface.
• Syntax:
public sealed class Animal permits Dog, Cat {}
•
• public final class Dog extends Animal {}
• public final class Cat extends Animal {}


// Declare a sealed interface
public sealed interface Shape permits Circle, Rectangle, Triangle {
    double area();
}

// Classes implementing the sealed interface
public final class Circle implements Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}

public final class Rectangle implements Shape {
    private double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double area() {
        return width * height;
    }
}

public final class Triangle implements Shape {
    private double base, height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }

    @Override
    public double area() {
        return 0.5 * base * height;
    }
}
2. Pattern Matching for switch (Preview)
• Improves: Type-checking and casting in switch statements.
• Example:
static String formatterPatternSwitch(Object o) {
•    return switch (o) {
•        case Integer i -> "int: " + i;
•        case Long l    -> "long: " + l;
•        case String s  -> "string: " + s;
•        default        -> "unknown";
•    };
• }
•
3. New instanceof Pattern Matching (Finalized in Java 16)
• Introduced in Java 16, but still relevant for Java 17 users.
• Simplifies type casting:
if (obj instanceof String s) { //Inline pattern matching and casting
•    System.out.println(s.toLowerCase());
• }
•
4. New switch Expressions (Preview in Java 12, Finalized later)
• Useful for returning values directly from switch.
int numLetters = switch (day) {
•    case MONDAY, FRIDAY, SUNDAY -> 6;
•    case TUESDAY                -> 7;
•    default                     -> throw new IllegalStateException("Invalid day");
• };
•
5. JEP 356: Enhanced Pseudo-Random Number Generators
• New interfaces and implementations for random number generators.
• Allows better stream-based generation:
RandomGenerator generator = RandomGeneratorFactory.of("L64X256MixRandom").create();
• int randomValue = generator.nextInt(100);
•
6. JEP 382: New macOS Rendering Pipeline
• Replaces Quartz with Metal framework on macOS for better performance and future compatibility.
7. JEP 389: Foreign Function & Memory API (Incubator)
• Allows Java to interoperate with native code and memory outside the JVM safely.
8. JEP 411: Deprecate Security Manager for Removal
• Security Manager is deprecated due to limited real-world usage and complexity.
9. Strong Encapsulation of JDK Internals
• Internal elements of the JDK are now strongly encapsulated, making reflection-based access harder.
10. Removal of Older Features
• Applet API: Marked for removal.
• RMI Activation: Removed.
• Experimental AOT and JIT compiler (Graal): Removed.

11.Java 17 improves garbage collection with enhancements to ZGC (Z Garbage Collector) 
and G1 Garbage Collector for better performance and lower latency.

******************************************************************************************************************************************************************************

What are the differences between collections and streams?
The collections in Java are mainly used to store and group the data. Meanwhile, streams are primarily used to process data.
In collections, you can also add or remove elements from collections. But you cannot add or remove elements from streams.

Collections are iterated externally, while streams are internally iterated. Collections can be traversed multiple times,
while streams can only be traversed once.

******************************************************************************************************************************************************************************

Java 8 StringJoiner is easily used to create a string with custom delimiters, prefixes, and suffixes.

It helps join strings like:

StringJoiner sj = new StringJoiner(", ", "[", "]");
sj.add("A").add("B").add("C");
System.out.println(sj); // Output: [A, B, C]

******************************************************************************************************************************************************************************

In Java, both Comparator.comparing and a normal comparator are used to define custom sorting logic, 
especially when sorting collections like lists. Here's a breakdown of the difference and usage:

1. Normal Comparator (Anonymous Class or Lambda)
A normal comparator explicitly defines the comparison logic.
Example:
List<String> names = Arrays.asList("John", "Alice", "Bob");
// Using a normal comparator with lambda
Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
// Or with anonymous inner class
Collections.sort(names, new Comparator<String>() {
   public int compare(String s1, String s2) {
       return s1.compareTo(s2);
   }
});
2. Comparator.comparing
Comparator.comparing is a static utility method added in Java 8. It makes comparator creation cleaner, 
especially when sorting by object fields.

Example:
class Person {
   String name;
   int age;
   // Constructor and getters
   Person(String name, int age) {
       this.name = name;
       this.age = age;
   }
   public int getAge() {
       return age;
   }
}
List<Person> people = Arrays.asList(
   new Person("Alice", 30),
   new Person("Bob", 25),
   new Person("John", 35)
);
// Using Comparator.comparing
people.sort(Comparator.comparing(Person::getAge));

******************************************************************************************************************************************************************************
A Spliterator in Java 8 is a special iterator used for splitting and traversing elements, especially in parallel streams.

The key features are as follows:

Traversal: Like an iterator, it visits elements one by one
Partitioning: Can split the data source for parallel processing using trySplit()
Parallelism: Optimized for use with parallel streams
Characteristics: Informs about data traits (e.g., ORDERED, SIZED)
Methods:
tryAdvance(): Processes the next element
trySplit(): Splits the data for parallel execution

******************************************************************************************************************************************************************************
Java 11 features

String Class Enhancements

New utility methods:
isBlank(): Checks if the string is empty or contains only white space.
lines(): Returns a stream of lines extracted from the string.
strip(), stripLeading(), stripTrailing(): Remove whitespaces from the string.
repeat(int): Repeats the string n times.

Files.readString() and Files.writeString()

Simplified reading and writing of strings to files with new static methods.
